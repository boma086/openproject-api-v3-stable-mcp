// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse, RequestConfig } from '../../http/types';
import { RequestBuilder } from '../../http/transport/request-builder';
import { SerializationStyle } from '../../http/serialization/base-serializer';
import { ThrowableError } from '../../http/errors/throwable-error';
import { Environment } from '../../http/environment';
import { AttachmentModel, attachmentModelResponse } from '../common/attachment-model';
import { AttachmentsModel, attachmentsModelResponse } from '../common/attachments-model';

export class AttachmentsService extends BaseService {
  /**
 * Clients can create attachments without a container first and attach them later on.This is useful if the container does not exist at the time the attachment is uploaded.
After the upload, the client can then claim such containerless attachments for any resource eligible (e.g. WorkPackage) on subsequent requests.
The upload and the claiming *must* be done for the same user account. Attachments uploaded by another user cannot be claimed and
once claimed for a resource, they cannot be claimed by another.

The upload request must be of type `multipart/form-data` with exactly two parts.

The first part *must* be called `metadata`. Its content type is expected to be `application/json`,
the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.

The second part *must* be called `file`, its content type *should* match the mime type of the file.
The body *must* be the raw content of the file.
Note that a `filename` *must* be indicated in the `Content-Disposition` of this part, although it will be ignored.
Instead the `fileName` inside the JSON of the metadata part will be used.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<AttachmentModel>>} OK
 */
  async createAttachment(requestConfig?: RequestConfig): Promise<HttpResponse<AttachmentModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: attachmentModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .build();
    return this.client.call<AttachmentModel>(request);
  }

  /**
   *
   * @param {number} id - Attachment id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<AttachmentModel>>} OK
   */
  async viewAttachment(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<AttachmentModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/attachments/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: attachmentModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<AttachmentModel>(request);
  }

  /**
 * Permanently deletes the specified attachment.
 * @param {number} id - Attachment id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} Returned if the attachment was deleted successfully.

Note that the response body is empty as of now. In future versions of the API a body
*might* be returned along with an appropriate HTTP status.
 */
  async deleteAttachment(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('DELETE')
      .setPath('/api/v3/attachments/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 204,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
   *
   * @param {number} id - ID of the meeting whose attachments will be listed
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<AttachmentsModel>>} OK
   */
  async listAttachmentsByMeeting(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<AttachmentsModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/meetings/{id}/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: attachmentsModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<AttachmentsModel>(request);
  }

  /**
   * Adds an attachment with the meeting as its container.
   * @param {number} id - ID of the meeting to receive the attachment
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async addAttachmentToMeeting(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/meetings/{id}/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   *
   * @param {number} id - ID of the post whose attachments will be listed
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<AttachmentsModel>>} OK
   */
  async listAttachmentsByPost(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<AttachmentsModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/posts/{id}/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: attachmentsModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<AttachmentsModel>(request);
  }

  /**
   * Adds an attachment with the post as its container.
   * @param {number} id - ID of the post to receive the attachment
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async addAttachmentToPost(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/posts/{id}/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   *
   * @param {number} id - ID of the wiki page whose attachments will be listed
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<AttachmentsModel>>} OK
   */
  async listAttachmentsByWikiPage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<AttachmentsModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/wiki_pages/{id}/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: attachmentsModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<AttachmentsModel>(request);
  }

  /**
   * Adds an attachment with the wiki page as its container.
   * @param {number} id - ID of the wiki page to receive the attachment
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async addAttachmentToWikiPage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/wiki_pages/{id}/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   *
   * @param {number} id - ID of the work package whose attachments will be listed
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<AttachmentsModel>>} OK
   */
  async listWorkPackageAttachments(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<AttachmentsModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: attachmentsModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<AttachmentsModel>(request);
  }

  /**
 * To add an attachment to a work package, a client needs to issue a request of type `multipart/form-data`with exactly two parts.

The first part *must* be called `metadata`. Its content type is expected to be `application/json`,
the body *must* be a single JSON object, containing at least the `fileName` and optionally the attachments `description`.

The second part *must* be called `file`, its content type *should* match the mime type of the file.
The body *must* be the raw content of the file.
Note that a `filename` must be indicated in the `Content-Disposition` of this part, however it will be ignored.
Instead the `fileName` inside the JSON of the metadata part will be used.
 * @param {number} id - ID of the work package to receive the attachment
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<AttachmentModel>>} OK
 */
  async createWorkPackageAttachment(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<AttachmentModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/work_packages/{id}/attachments')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: attachmentModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<AttachmentModel>(request);
  }
}
