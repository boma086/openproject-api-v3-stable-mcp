// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse, RequestConfig } from '../../http/types';
import { RequestBuilder } from '../../http/transport/request-builder';
import { SerializationStyle } from '../../http/serialization/base-serializer';
import { ThrowableError } from '../../http/errors/throwable-error';
import { Environment } from '../../http/environment';
import { GroupCollectionModel, groupCollectionModelResponse } from './models/group-collection-model';
import { ListGroupsParams } from './request-params';
import { GroupWriteModel, groupWriteModelRequest } from './models/group-write-model';
import { GroupModel, groupModelResponse } from '../common/group-model';

export class GroupsService extends BaseService {
  /**
 * Returns a collection of groups. The client can choose to filter thegroups similar to how work packages are filtered. In addition to the provided
filters, the server will reduce the result set to only contain groups, for which
the requesting client has sufficient permissions (*view_members*, *manage_members*).
 * @param {string} [params.sortBy] - JSON specifying sort criteria.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported sorts are:

+ id: Sort by primary key

+ created_at: Sort by group creation datetime

+ updated_at: Sort by the time the group was updated last
 * @param {string} [params.select] - Comma separated list of properties to include.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<GroupCollectionModel>>} OK
 */
  async listGroups(
    params?: ListGroupsParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<GroupCollectionModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/groups')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: groupCollectionModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'sortBy',
        value: params?.sortBy,
      })
      .addQueryParam({
        key: 'select',
        value: params?.select,
      })
      .build();
    return this.client.call<GroupCollectionModel>(request);
  }

  /**
   * Creates a new group applying the attributes provided in the body.
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<GroupModel>>} Created
   */
  async createGroup(body: GroupWriteModel, requestConfig?: RequestConfig): Promise<HttpResponse<GroupModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/groups')
      .setRequestSchema(groupWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: groupModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<GroupModel>(request);
  }

  /**
   * Fetches a group resource.
   * @param {number} id - Group id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<GroupModel>>} OK
   */
  async getGroup(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<GroupModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/groups/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: groupModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<GroupModel>(request);
  }

  /**
 * Updates the given group by applying the attributes provided in the body.
Please note that the `members` array provided will override the existing set of members (similar to a PUT). A
client thus has to provide the complete list of members the group is to have after the PATCH even if only one
member is to be added.
 * @param {number} id - Group id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<GroupModel>>} OK
 */
  async updateGroup(
    id: number,
    body: GroupWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<GroupModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('PATCH')
      .setPath('/api/v3/groups/{id}')
      .setRequestSchema(groupWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: groupModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<GroupModel>(request);
  }

  /**
 * Deletes the group.
 * @param {number} id - Group id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} Returned if the group was marked for deletion.

Note that the response body is empty as of now. In future versions of the API a body
*might* be returned, indicating the progress of deletion.
 */
  async deleteGroup(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('DELETE')
      .setPath('/api/v3/groups/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 202,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }
}
