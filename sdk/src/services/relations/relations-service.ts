// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse, RequestConfig } from '../../http/types';
import { RequestBuilder } from '../../http/transport/request-builder';
import { SerializationStyle } from '../../http/serialization/base-serializer';
import { ThrowableError } from '../../http/errors/throwable-error';
import { Environment } from '../../http/environment';
import { RelationCollectionModel, relationCollectionModelResponse } from './models/relation-collection-model';
import { ListRelationsParams } from './request-params';
import { RelationReadModel, relationReadModelResponse } from './models/relation-read-model';
import { RelationWriteModel, relationWriteModelRequest } from './models/relation-write-model';

export class RelationsService extends BaseService {
  /**
 * Lists all relations according to the given (optional, logically conjunctive) filters and ordered by ID.The response only includes relations between work packages which the user is allowed to see.
 * @param {string} [params.filters] - JSON specifying filter conditions. Accepts the same format as returned by
the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Valid fields to filter by are:

- id - ID of relation
- from - ID of work package from which the filtered relations emanates.
- to - ID of work package to which this related points.
- involved - ID of either the `from` or the `to` work package.
- type - The type of relation to filter by, e.g. "follows".
 * @param {string} [params.sortBy] - JSON specifying sort criteria.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<RelationCollectionModel>>} OK
 */
  async listRelations(
    params?: ListRelationsParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<RelationCollectionModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/relations')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: relationCollectionModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .addQueryParam({
        key: 'sortBy',
        value: params?.sortBy,
      })
      .build();
    return this.client.call<RelationCollectionModel>(request);
  }

  /**
   * Get a single relation specified by its unique identifier.
   * @param {number} id - Relation id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<RelationReadModel>>} OK
   */
  async getRelation(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<RelationReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/relations/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: relationReadModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<RelationReadModel>(request);
  }

  /**
 * When calling this endpoint the client provides a single object, containing the properties and links that it wantsto change, in the body. It is only allowed to provide properties or links supporting the **write** operation.

Note that changing the `type` of a relation invariably also changes the respective `reverseType` as well as the
"name" of it. The returned Relation object will reflect that change. For instance if you change a Relation's
`type` to "follows" then the `reverseType` will be changed to `precedes`.

It is not allowed to change a relation's involved work packages.
 * @param {number} id - Relation ID
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<RelationReadModel>>} OK
 */
  async updateRelation(
    id: number,
    body: RelationWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<RelationReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('PATCH')
      .setPath('/api/v3/relations/{id}')
      .setRequestSchema(relationWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: relationReadModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<RelationReadModel>(request);
  }

  /**
   * Deletes the relation.
   * @param {number} id - The unique identifier of the relation resource
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} Returned if the relation was deleted successfully. The response body is empty.
   */
  async deleteRelation(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('DELETE')
      .setPath('/api/v3/relations/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 204,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
   * Create a work package relation on the given work package. A successful creation will result in a relation betweentwo work packages, thus appearing on both involved work package resources.
   * @param {number} id - Work package id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<RelationReadModel>>} Created
   */
  async createRelation(
    id: number,
    body: RelationWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<RelationReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/work_packages/{id}/relations')
      .setRequestSchema(relationWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: relationReadModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<RelationReadModel>(request);
  }
}
