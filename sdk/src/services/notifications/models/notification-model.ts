// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { NotificationModelType, notificationModelType } from './notification-model-type';
import { Reason, reason } from './reason';
import {
  ValuesPropertyModel,
  valuesPropertyModel,
  valuesPropertyModelRequest,
  valuesPropertyModelResponse,
} from './values-property-model';
import {
  NotificationModelEmbedded,
  notificationModelEmbedded,
  notificationModelEmbeddedRequest,
  notificationModelEmbeddedResponse,
} from './notification-model-embedded';
import {
  NotificationModelLinks,
  notificationModelLinks,
  notificationModelLinksRequest,
  notificationModelLinksResponse,
} from './notification-model-links';

/**
 * The shape of the model inside the application code - what the users use
 */
export const notificationModel = z.lazy(() => {
  return z.object({
    _type: notificationModelType.optional(),
    id: z.number().gte(1).optional(),
    reason: reason.optional(),
    readIan: z.boolean().optional(),
    details: z.array(valuesPropertyModel).optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
    _embedded: notificationModelEmbedded.optional(),
    _links: notificationModelLinks.optional(),
  });
});

/**
 *
 * @typedef  {NotificationModel} notificationModel
 * @property {NotificationModelType}
 * @property {number} - Notification id
 * @property {Reason} - The reason for the notification
 * @property {boolean} - Whether the notification is marked as read
 * @property {ValuesPropertyModel[]} - A list of objects including detailed information about the notification.
 * @property {string} - The time the notification was created at
 * @property {string} - The time the notification was last updated
 * @property {NotificationModelEmbedded}
 * @property {NotificationModelLinks}
 */
export type NotificationModel = z.infer<typeof notificationModel>;

/**
 * The shape of the model mapping from the api schema into the application shape.
 * Is equal to application shape if all property names match the api schema
 */
export const notificationModelResponse = z.lazy(() => {
  return z
    .object({
      _type: notificationModelType.optional(),
      id: z.number().gte(1).optional(),
      reason: reason.optional(),
      readIAN: z.boolean().optional(),
      details: z.array(valuesPropertyModelResponse).optional(),
      createdAt: z.string().optional(),
      updatedAt: z.string().optional(),
      _embedded: notificationModelEmbeddedResponse.optional(),
      _links: notificationModelLinksResponse.optional(),
    })
    .transform((data) => ({
      _type: data['_type'],
      id: data['id'],
      reason: data['reason'],
      readIan: data['readIAN'],
      details: data['details'],
      createdAt: data['createdAt'],
      updatedAt: data['updatedAt'],
      _embedded: data['_embedded'],
      _links: data['_links'],
    }));
});

/**
 * The shape of the model mapping from the application shape into the api schema.
 * Is equal to application shape if all property names match the api schema
 */
export const notificationModelRequest = z.lazy(() => {
  return z
    .object({
      _type: notificationModelType.optional(),
      id: z.number().gte(1).optional(),
      reason: reason.optional(),
      readIan: z.boolean().optional(),
      details: z.array(valuesPropertyModelRequest).optional(),
      createdAt: z.string().optional(),
      updatedAt: z.string().optional(),
      _embedded: notificationModelEmbeddedRequest.optional(),
      _links: notificationModelLinksRequest.optional(),
    })
    .transform((data) => ({
      _type: data['_type'],
      id: data['id'],
      reason: data['reason'],
      readIAN: data['readIan'],
      details: data['details'],
      createdAt: data['createdAt'],
      updatedAt: data['updatedAt'],
      _embedded: data['_embedded'],
      _links: data['_links'],
    }));
});
