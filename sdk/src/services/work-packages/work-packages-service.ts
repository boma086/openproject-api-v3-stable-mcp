// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse, RequestConfig } from '../../http/types';
import { RequestBuilder } from '../../http/transport/request-builder';
import { SerializationStyle } from '../../http/serialization/base-serializer';
import { ThrowableError } from '../../http/errors/throwable-error';
import { Environment } from '../../http/environment';
import { WorkPackagesModel, workPackagesModelResponse } from './models/work-packages-model';
import {
  CommentWorkPackageParams,
  CreateProjectWorkPackageParams,
  CreateWorkPackageParams,
  GetProjectWorkPackageCollectionParams,
  ListAvailableRelationCandidatesParams,
  ListWorkPackageFileLinksParams,
  ListWorkPackageSchemasParams,
  ListWorkPackagesParams,
  UpdateWorkPackageParams,
  ViewWorkPackageParams,
} from './request-params';
import { WorkPackageModel, workPackageModelRequest, workPackageModelResponse } from '../common/work-package-model';
import { WorkPackageWriteModel, workPackageWriteModelRequest } from './models/work-package-write-model';
import { WorkPackageFormModel, workPackageFormModelResponse } from './models/work-package-form-model';
import { AvailableAssigneesModel, availableAssigneesModelResponse } from './models/available-assignees-model';
import { WorkPackagePatchModel, workPackagePatchModelResponse } from './models/work-package-patch-model';
import { CommentWorkPackageRequest, commentWorkPackageRequestRequest } from './models/comment-work-package-request';
import {
  FileLinkCollectionReadModel,
  fileLinkCollectionReadModelResponse,
} from './models/file-link-collection-read-model';
import {
  FileLinkCollectionWriteModel,
  fileLinkCollectionWriteModelRequest,
} from './models/file-link-collection-write-model';
import { ReminderModel, reminderModelResponse } from './models/reminder-model';
import { WatchersModel, watchersModelResponse } from './models/watchers-model';
import { AddWatcherRequest, addWatcherRequestRequest } from './models/add-watcher-request';

export class WorkPackagesService extends BaseService {
  /**
 * Returns the collection of work packages that are related to the given project.
 * @param {number} id - Project id
 * @param {number} [params.offset] - Page number inside the requested collection.
 * @param {number} [params.pageSize] - Number of elements to display per page.
 * @param {string} [params.filters] - JSON specifying filter conditions.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. If no filter is to be applied, the client should send an empty array (`[]`).
 * @param {string} [params.sortBy] - JSON specifying sort criteria.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
 * @param {string} [params.groupBy] - The column to group by.
 * @param {boolean} [params.showSums] - Indicates whether properties should be summed up if they support it.
 * @param {string} [params.select] - Comma separated list of properties to include.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackagesModel>>} OK
 */
  async getProjectWorkPackageCollection(
    id: number,
    params?: GetProjectWorkPackageCollectionParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackagesModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/projects/{id}/work_packages')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackagesModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'offset',
        value: params?.offset,
      })
      .addQueryParam({
        key: 'pageSize',
        value: params?.pageSize,
      })
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .addQueryParam({
        key: 'sortBy',
        value: params?.sortBy,
      })
      .addQueryParam({
        key: 'groupBy',
        value: params?.groupBy,
      })
      .addQueryParam({
        key: 'showSums',
        value: params?.showSums,
      })
      .addQueryParam({
        key: 'select',
        value: params?.select,
      })
      .build();
    return this.client.call<WorkPackagesModel>(request);
  }

  /**
 * When calling this endpoint the client provides a single object, containing at least the properties and links thatare required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in
the respective form. Note that it is only allowed to provide properties or links supporting the write operation.
 * @param {number} id - Project id
 * @param {boolean} [params.notify] - Indicates whether change notifications (e.g. via E-Mail) should be sent.
Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee),
not just the current user.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackageModel>>} OK
 */
  async createProjectWorkPackage(
    id: number,
    body: WorkPackageModel,
    params?: CreateProjectWorkPackageParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackageModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/projects/{id}/work_packages')
      .setRequestSchema(workPackageModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackageModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'notify',
        value: params?.notify,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<WorkPackageModel>(request);
  }

  /**
 * This endpoint allows you to validation a new work package creation body in a specific project. It works similarlyto the `/api/v3/work_packages/form` endpoint, but already specifies the work package's project in the path, so that
it does not have to be defined in the request body.
 * @param {number} id - ID of the project in which the work package will be created
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackageFormModel>>} OK
 */
  async formCreateWorkPackageInProject(
    id: number,
    body: WorkPackageWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackageFormModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/projects/{id}/work_packages/form')
      .setRequestSchema(workPackageWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackageFormModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<WorkPackageFormModel>(request);
  }

  /**
   * Gets a list of users that can be assigned to work packages in the given project.
   * @param {number} id - Project id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<AvailableAssigneesModel>>} OK
   */
  async projectAvailableAssignees(
    id: number,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<AvailableAssigneesModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/projects/{id}/available_assignees')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: availableAssigneesModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<AvailableAssigneesModel>(request);
  }

  /**
 * Returns a collection of work packages.
 * @param {number} [params.offset] - Page number inside the requested collection.
 * @param {number} [params.pageSize] - Number of elements to display per page.
 * @param {string} [params.filters] - JSON specifying filter conditions.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/)
endpoint. If no filter is to be applied, the client should send an empty array (`[]`), otherwise a default
filter is applied. A Currently supported filters are (there are additional filters added by modules):

- assigned_to
- assignee_or_group
- attachment_base
- attachment_content
- attachment_file_name
- author
- blocked
- blocks
- category
- comment
- created_at
- custom_field
- dates_interval
- description
- done_ratio
- due_date
- duplicated
- duplicates
- duration
- estimated_hours
- file_link_origin_id
- follows
- group
- id
- includes
- linkable_to_storage_id
- linkable_to_storage_url
- manual_sort
- milestone
- only_subproject
- parent
- partof
- precedes
- principal_base
- priority
- project
- relatable
- relates
- required
- requires
- responsible
- role
- search
- start_date
- status
- storage_id
- storage_url
- subject
- subject_or_id
- subproject
- type
- typeahead
- updated_at
- version
- watcher
- work_package
 * @param {string} [params.sortBy] - JSON specifying sort criteria.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint.
 * @param {string} [params.groupBy] - The column to group by.
 * @param {boolean} [params.showSums] - Indicates whether properties should be summed up if they support it.
 * @param {string} [params.select] - Comma separated list of properties to include.
 * @param {string} [params.timestamps] - In order to perform a [baseline comparison](/docs/api/baseline-comparisons), you may provide one or several timestamps
in ISO-8601 format as comma-separated list. The timestamps may be absolute or relative,
such as ISO8601 dates, ISO8601 durations and the following relative date keywords: "oneDayAgo@HH:MM+HH:MM",
"lastWorkingDay@HH:MM+HH:MM", "oneWeekAgo@HH:MM+HH:MM", "oneMonthAgo@HH:MM+HH:MM".
The first "HH:MM" part represents the zero paded hours and minutes.
The last "+HH:MM" part represents the timezone offset from UTC associated with the time,
the offset can be positive or negative e.g."oneDayAgo@01:00+01:00", "oneDayAgo@01:00-01:00".

Usually, the first timestamp is the baseline date, the last timestamp is the current date.
Values older than 1 day are accepted only with valid Enterprise Token available.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackagesModel>>} OK
 */
  async listWorkPackages(
    params?: ListWorkPackagesParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackagesModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackagesModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'offset',
        value: params?.offset,
      })
      .addQueryParam({
        key: 'pageSize',
        value: params?.pageSize,
      })
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .addQueryParam({
        key: 'sortBy',
        value: params?.sortBy,
      })
      .addQueryParam({
        key: 'groupBy',
        value: params?.groupBy,
      })
      .addQueryParam({
        key: 'showSums',
        value: params?.showSums,
      })
      .addQueryParam({
        key: 'select',
        value: params?.select,
      })
      .addQueryParam({
        key: 'timestamps',
        value: params?.timestamps,
      })
      .build();
    return this.client.call<WorkPackagesModel>(request);
  }

  /**
 * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form.
Note that it is only allowed to provide properties or links supporting the write operation.

A project link must be set when creating work packages through this route.

When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value: set only two values in the request and the third one will be computed and returned in the response. For instance, when sending `{ "startDate": "2022-08-23", duration: "P2D" }`, the response will include `{ "dueDate": "2022-08-24" }`.
 * @param {boolean} [params.notify] - Indicates whether change notifications (e.g. via E-Mail) should be sent.
Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee),
not just the current user.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackageModel>>} OK
 */
  async createWorkPackage(
    body: WorkPackageModel,
    params?: CreateWorkPackageParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackageModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/work_packages')
      .setRequestSchema(workPackageModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackageModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'notify',
        value: params?.notify,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<WorkPackageModel>(request);
  }

  /**
 * When calling this endpoint, the client provides a single object containing the properties and links to becreated, in the body. The input is validated and a schema response is returned. If the validation errors of the
response is empty, the same payload can be used to create a work package.

Only the properties of the work package write model are allowed to set on a work package on creation.

When setting start date, finish date, and duration together, their correctness will be checked and a validation
error will be returned if one value does not match with the two others. You can make the server compute a value:
set only two values in the request and the third one will be computed and returned in the response. For instance,
when sending `{ "startDate": "2022-08-23", duration: "P2D" }`, the response will
include `{ "dueDate": "2022-08-24" }`.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackageFormModel>>} OK
 */
  async formCreateWorkPackage(
    body: WorkPackageWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackageFormModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/work_packages/form')
      .setRequestSchema(workPackageWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackageFormModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<WorkPackageFormModel>(request);
  }

  /**
 * List all work package schemas that match the given filters. This endpoint does not return a successful response,if no filter is given.
 * @param {string} filters - JSON specifying filter conditions.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/)
endpoint. Currently supported filters are:

+ id: The schema's id

Schema id has the form `project_id-work_package_type_id`.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async listWorkPackageSchemas(
    params: ListWorkPackageSchemasParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/schemas')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   *
   * @param {string} identifier - Identifier of the schema
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async viewWorkPackageSchema(identifier: string, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/schemas/{identifier}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'identifier',
        value: identifier,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
 * Returns the specified work package.
 * @param {number} id - Work package id
 * @param {string} [params.timestamps] - In order to perform a [baseline comparison](/docs/api/baseline-comparisons) of the work-package attributes, you may
provide one or several timestamps in ISO-8601 format as comma-separated list. The timestamps may be absolute or relative,
such as ISO8601 dates, ISO8601 durations and the following relative date keywords: "oneDayAgo@HH:MM+HH:MM",
"lastWorkingDay@HH:MM+HH:MM", "oneWeekAgo@HH:MM+HH:MM", "oneMonthAgo@HH:MM+HH:MM".
The first "HH:MM" part represents the zero paded hours and minutes.
The last "+HH:MM" part represents the timezone offset from UTC associated with the time,
the offset can be positive or negative e.g."oneDayAgo@01:00+01:00", "oneDayAgo@01:00-01:00".

Usually, the first timestamp is the baseline date, the last timestamp is the current date.
Values older than 1 day are accepted only with valid Enterprise Token available.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackageModel>>} OK
 */
  async viewWorkPackage(
    id: number,
    params?: ViewWorkPackageParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackageModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackageModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'timestamps',
        value: params?.timestamps,
      })
      .build();
    return this.client.call<WorkPackageModel>(request);
  }

  /**
 * When calling this endpoint the client provides a single object, containing the properties and links that it wantsto change, in the body. Note that it is only allowed to provide properties or links supporting the **write**
operation.

Additionally to the fields the client wants to change, it is mandatory to provide the value of `lockVersion` which
was received by the `GET` request this change originates from.

The value of `lockVersion` is used to implement
[optimistic locking](https://en.wikipedia.org/wiki/Optimistic_concurrency_control).
 * @param {number} id - Work package id
 * @param {boolean} [params.notify] - Indicates whether change notifications should be sent. Note that this controls notifications for all users
interested in changes to the work package (e.g. watchers, author and assignee), not just the current user.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackagePatchModel>>} OK
 */
  async updateWorkPackage(
    id: number,
    body: WorkPackageModel,
    params?: UpdateWorkPackageParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackagePatchModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('PATCH')
      .setPath('/api/v3/work_packages/{id}')
      .setRequestSchema(workPackageModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackagePatchModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'notify',
        value: params?.notify,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<WorkPackagePatchModel>(request);
  }

  /**
 * Deletes the work package, as well as:
- all associated time entries
- its hierarchy of child work packages
 * @param {number} id - Work package id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} Returned if the work package was deleted successfully.

Note that the response body is empty as of now. In future versions of the API a body
*might* be returned along with an appropriate HTTP status.
 */
  async deleteWorkPackage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('DELETE')
      .setPath('/api/v3/work_packages/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 204,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
   *
   * @param {number} id - Work package id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async listWorkPackageActivities(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/activities')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
 * Creates an activity for the selected work package and, on success, returns theupdated activity.
 * @param {number} id - Work package id
 * @param {boolean} [params.notify] - Indicates whether change notifications (e.g. via E-Mail) should be sent.
Note that this controls notifications for all users interested in changes to the work package (e.g. watchers, author and assignee),
not just the current user.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} Created
 */
  async commentWorkPackage(
    id: number,
    body: CommentWorkPackageRequest,
    params?: CommentWorkPackageParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/work_packages/{id}/activities')
      .setRequestSchema(commentWorkPackageRequestRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'notify',
        value: params?.notify,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<void>(request);
  }

  /**
   * Gets a list of users that can be assigned to the given work package.
   * @param {number} id - Work package id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<AvailableAssigneesModel>>} OK
   */
  async workPackageAvailableAssignees(
    id: number,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<AvailableAssigneesModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/available_assignees')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: availableAssigneesModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<AvailableAssigneesModel>(request);
  }

  /**
   * Gets a list of projects that are available as projects to which the work package can be moved.
   * @param {number} id - work package id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async availableProjectsForWorkPackage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/available_projects')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
 * 
 * @param {number} id - Project id
 * @param {number} [params.pageSize] - Maximum number of candidates to list (default 10)
 * @param {string} [params.filters] - JSON specifying filter conditions.
Accepts the same filters as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
 * @param {string} [params.query] - Shortcut for filtering by ID or subject
 * @param {string} [params.type] - Type of relation to find candidates for (default "relates")
 * @param {string} [params.sortBy] - JSON specifying sort criteria.
Accepts the same sort criteria as the [work packages](https://www.openproject.org/docs/api/endpoints/work-packages/) endpoint.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async listAvailableRelationCandidates(
    id: number,
    params?: ListAvailableRelationCandidatesParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/available_relation_candidates')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'pageSize',
        value: params?.pageSize,
      })
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .addQueryParam({
        key: 'query',
        value: params?.query,
      })
      .addQueryParam({
        key: 'type',
        value: params?.type,
      })
      .addQueryParam({
        key: 'sortBy',
        value: params?.sortBy,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   * Gets a list of users that are able to be watchers of the specified work package.
   * @param {number} id - work package id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async availableWatchers(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/available_watchers')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
 * Gets all file links of a work package.
As a side effect, for every file link a request is sent to the storage's origin to fetch live data and patch
the file link's data before returning, as well as retrieving permissions of the user on this origin file. 
 * @param {number} id - Work package id
 * @param {string} [params.filters] - JSON specifying filter conditions.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/)
endpoint. The following filters are supported:

- storage
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<FileLinkCollectionReadModel>>} OK
 */
  async listWorkPackageFileLinks(
    id: number,
    params?: ListWorkPackageFileLinksParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<FileLinkCollectionReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/file_links')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: fileLinkCollectionReadModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .build();
    return this.client.call<FileLinkCollectionReadModel>(request);
  }

  /**
 * Creates file links on a work package.
The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each
element contains the origin meta data and a link to the storage, the file link is about to point to. The storage
link can be provided as a resource link with id or as the host url.

The file's id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided
by the client. The _mimeType_ SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link
a folder, the custom mime type `application/x-op-directory` MUST be used.

Up to 20 file links can be submitted at once.

If any element data is invalid, no file links will be created.

If a file link with matching origin id, work package, and storage already exists, then it will not create an
additional file link or update the meta data. Instead the information from the existing file link will be returned.
 * @param {number} id - Work package id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<FileLinkCollectionReadModel>>} Created
 */
  async createWorkPackageFileLink(
    id: number,
    body: FileLinkCollectionWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<FileLinkCollectionReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/work_packages/{id}/file_links')
      .setRequestSchema(fileLinkCollectionWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: fileLinkCollectionReadModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<FileLinkCollectionReadModel>(request);
  }

  /**
 * When calling this endpoint, the client provides a single object containing the properties and links to beedited, in the body. The input is validated and a schema response is returned. If the validation errors of the
response is empty, the same payload can be used to edit the work package.

Only the properties of the work package write model are allowed to set on a work package on editing.

When setting start date, finish date, and duration together, their correctness will be checked and a validation
error will be returned if one value does not match with the two others. You can make the server compute a value:
set only two values in the request and the third one will be computed and returned in the response. For instance,
when sending `{ "startDate": "2022-08-23", duration: "P2D" }`, the response will
include `{ "dueDate": "2022-08-24" }`.
 * @param {number} id - ID of the work package being modified
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<WorkPackageFormModel>>} OK
 */
  async formEditWorkPackage(
    id: number,
    body: WorkPackageWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<WorkPackageFormModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/work_packages/{id}/form')
      .setRequestSchema(workPackageWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: workPackageFormModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<WorkPackageFormModel>(request);
  }

  /**
   * Gets a list of revisions that are linked to this work package, e.g., because it is referenced in the commit message of the revision.Only linked revisions from repositories are shown if the user has the view changesets permission in the defining project.
   * @param {number} id - Work package id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async revisions(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/revisions')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   * Gets a list of your upcoming reminders for this work package.
   * @param {number} id - Work package id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<ReminderModel>>} OK
   */
  async reminders(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<ReminderModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/reminders')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: reminderModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<ReminderModel>(request);
  }

  /**
   *
   * @param {number} id - Work package id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<WatchersModel>>} OK
   */
  async listWatchers(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<WatchersModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/work_packages/{id}/watchers')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: watchersModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<WatchersModel>(request);
  }

  /**
 * Adds a watcher to the specified work package.
The request is expected to contain a single JSON object, that contains a link object under the `user` key.

The response will be user added as watcher.
In case the user was already watching the work package an `HTTP 200` is returned, an
`HTTP 201` if the user was added as a new watcher.
 * @param {number} id - Work package id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async addWatcher(
    id: number,
    body: AddWatcherRequest,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<void | void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/work_packages/{id}/watchers')
      .setRequestSchema(addWatcherRequestRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 200,
      })
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<void | void>(request);
  }

  /**
 * Removes the specified user from the list of watchers for the given work package.
If the request succeeds, the specified user is not watching the work package anymore.

*Note: This might also be the case, if the specified user did not watch the work package prior to the request.*
 * @param {number} id - Work package id
 * @param {number} userId - User id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} No Content
 */
  async removeWatcher(id: number, userId: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('DELETE')
      .setPath('/api/v3/work_packages/{id}/watchers/{user_id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 204,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addPathParam({
        key: 'user_id',
        value: userId,
      })
      .build();
    return this.client.call<void>(request);
  }
}
