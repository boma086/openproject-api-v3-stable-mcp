// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { GridReadModelType, gridReadModelType } from './grid-read-model-type';
import { GridWidgetModel, gridWidgetModel, gridWidgetModelRequest, gridWidgetModelResponse } from './grid-widget-model';
import {
  GridReadModelLinks,
  gridReadModelLinks,
  gridReadModelLinksRequest,
  gridReadModelLinksResponse,
} from './grid-read-model-links';

/**
 * The shape of the model inside the application code - what the users use
 */
export const gridReadModel = z.lazy(() => {
  return z.object({
    _type: gridReadModelType,
    id: z.number().gte(1),
    rowCount: z.number().gte(1),
    columnCount: z.number().gte(1),
    widgets: z.array(gridWidgetModel),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
    _links: gridReadModelLinks,
  });
});

/**
 * 
 * @typedef  {GridReadModel} gridReadModel   
 * @property {GridReadModelType} 
 * @property {number} - Grid's id
 * @property {number} - The number of rows the grid has
 * @property {number} - The number of columns the grid has
 * @property {GridWidgetModel[]} - The set of `GridWidget`s selected for the grid.

# Conditions

- The widgets must not overlap.
 * @property {string} - The time the grid was created.
 * @property {string} - The time the grid was last updated.
 * @property {GridReadModelLinks} 
 */
export type GridReadModel = z.infer<typeof gridReadModel>;

/**
 * The shape of the model mapping from the api schema into the application shape.
 * Is equal to application shape if all property names match the api schema
 */
export const gridReadModelResponse = z.lazy(() => {
  return z
    .object({
      _type: gridReadModelType,
      id: z.number().gte(1),
      rowCount: z.number().gte(1),
      columnCount: z.number().gte(1),
      widgets: z.array(gridWidgetModelResponse),
      createdAt: z.string().optional(),
      updatedAt: z.string().optional(),
      _links: gridReadModelLinksResponse,
    })
    .transform((data) => ({
      _type: data['_type'],
      id: data['id'],
      rowCount: data['rowCount'],
      columnCount: data['columnCount'],
      widgets: data['widgets'],
      createdAt: data['createdAt'],
      updatedAt: data['updatedAt'],
      _links: data['_links'],
    }));
});

/**
 * The shape of the model mapping from the application shape into the api schema.
 * Is equal to application shape if all property names match the api schema
 */
export const gridReadModelRequest = z.lazy(() => {
  return z
    .object({
      _type: gridReadModelType,
      id: z.number().gte(1),
      rowCount: z.number().gte(1),
      columnCount: z.number().gte(1),
      widgets: z.array(gridWidgetModelRequest),
      createdAt: z.string().optional(),
      updatedAt: z.string().optional(),
      _links: gridReadModelLinksRequest,
    })
    .transform((data) => ({
      _type: data['_type'],
      id: data['id'],
      rowCount: data['rowCount'],
      columnCount: data['columnCount'],
      widgets: data['widgets'],
      createdAt: data['createdAt'],
      updatedAt: data['updatedAt'],
      _links: data['_links'],
    }));
});
