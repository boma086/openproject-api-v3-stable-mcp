// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse, RequestConfig } from '../../http/types';
import { RequestBuilder } from '../../http/transport/request-builder';
import { SerializationStyle } from '../../http/serialization/base-serializer';
import { ThrowableError } from '../../http/errors/throwable-error';
import { Environment } from '../../http/environment';
import { GridCollectionModel, gridCollectionModelResponse } from './models/grid-collection-model';
import { ListGridsParams } from './request-params';
import { GridWriteModel, gridWriteModelRequest } from './models/grid-write-model';
import { GridReadModel, gridReadModelResponse } from './models/grid-read-model';

export class GridsService extends BaseService {
  /**
 * Lists all grids matching the provided filters and being part of the selected query page. The grids returned willalso depend on the permissions of the requesting user.
 * @param {number} [params.offset] - Page number inside the requested collection.
 * @param {number} [params.pageSize] - Number of elements to display per page.
 * @param {string} [params.filters] - JSON specifying filter conditions. Accepts the same format as returned by
the [queries](https://www.openproject.org/docs/api/endpoints/queries/) endpoint. Currently supported filters
are:

- page: Filter grid by work package
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<GridCollectionModel>>} OK
 */
  async listGrids(params?: ListGridsParams, requestConfig?: RequestConfig): Promise<HttpResponse<GridCollectionModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/grids')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: gridCollectionModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'offset',
        value: params?.offset,
      })
      .addQueryParam({
        key: 'pageSize',
        value: params?.pageSize,
      })
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .build();
    return this.client.call<GridCollectionModel>(request);
  }

  /**
 * Creates a new grid applying the attributes provided in the body. The constraints applied to the grid depend on thepage the grid is placed in which is why the create form end point should be used to be guided when wanting to
create a grid.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<GridReadModel>>} Created
 */
  async createGrid(body: GridWriteModel, requestConfig?: RequestConfig): Promise<HttpResponse<GridReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/grids')
      .setRequestSchema(gridWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: gridReadModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<GridReadModel>(request);
  }

  /**
   *
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async gridCreateForm(requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/grids/form')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .build();
    return this.client.call<void>(request);
  }

  /**
   * Fetches a single grid identified by its id.
   * @param {number} id - Grid id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<GridReadModel>>} OK
   */
  async getGrid(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<GridReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/grids/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: gridReadModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<GridReadModel>(request);
  }

  /**
 * Updates the given grid by applying the attributes provided in the body. The constraints applied to the grid dependon the page the grid is placed in which is why the create form end point should be used to be guided when wanting
to update a grid.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<GridReadModel>>} OK
 */
  async updateGrid(body: GridWriteModel, requestConfig?: RequestConfig): Promise<HttpResponse<GridReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('PATCH')
      .setPath('/api/v3/grids/{id}')
      .setRequestSchema(gridWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: gridReadModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<GridReadModel>(request);
  }

  /**
   *
   * @param {number} id - ID of the grid being modified
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async gridUpdateForm(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/grids/{id}/form')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }
}
