// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse, RequestConfig } from '../../http/types';
import { RequestBuilder } from '../../http/transport/request-builder';
import { SerializationStyle } from '../../http/serialization/base-serializer';
import { ThrowableError } from '../../http/errors/throwable-error';
import { Environment } from '../../http/environment';
import { FileLinkReadModel, fileLinkReadModelResponse } from '../common/file-link-read-model';
import { GetStorageFilesParams, ListProjectStoragesParams, OpenFileLinkParams } from './request-params';
import {
  ProjectStorageCollectionModel,
  projectStorageCollectionModelResponse,
} from './models/project-storage-collection-model';
import { ProjectStorageModel, projectStorageModelResponse } from './models/project-storage-model';
import { StorageCollectionModel, storageCollectionModelResponse } from './models/storage-collection-model';
import { StorageWriteModel, storageWriteModelRequest } from './models/storage-write-model';
import { StorageReadModel, storageReadModelResponse } from './models/storage-read-model';
import { StorageFilesModel, storageFilesModelResponse } from './models/storage-files-model';
import {
  StorageFileUploadPreparationModel,
  storageFileUploadPreparationModelRequest,
} from './models/storage-file-upload-preparation-model';
import {
  StorageFileUploadLinkModel,
  storageFileUploadLinkModelResponse,
} from './models/storage-file-upload-link-model';
import { StorageFolderWriteModel, storageFolderWriteModelRequest } from './models/storage-folder-write-model';
import { StorageFileModel, storageFileModelResponse } from './models/storage-file-model';
import {
  OAuthClientCredentialsWriteModel,
  oAuthClientCredentialsWriteModelRequest,
} from './models/o-auth-client-credentials-write-model';

export class FileLinksService extends BaseService {
  /**
   * Gets a single file link resource of a work package.
   * @param {number} id - File link id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<FileLinkReadModel>>} OK
   */
  async viewFileLink(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<FileLinkReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/file_links/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: fileLinkReadModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<FileLinkReadModel>(request);
  }

  /**
 * Removes a file link on a work package.
The request contains only the file link identifier as a path parameter. No request body is needed.
 * @param {number} id - File link id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async deleteFileLink(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('DELETE')
      .setPath('/api/v3/file_links/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
 * Creates a uri to open the origin file linked by the given file link. This uri depends on the storage type andis always located on the origin storage itself.
 * @param {number} id - File link id
 * @param {boolean} [params.location] - Boolean flag indicating, if the file should be opened directly or rather the directory location.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} Returned if the request was successful. In the `Location` header is the uri where the client can open the origin
file on the storage.
 */
  async openFileLink(
    id: number,
    params?: OpenFileLinkParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/file_links/{id}/open')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 303,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'location',
        value: params?.location,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
 * Creates a uri to download the origin file linked by the given file link. This uri depends on the storage type andis always located on the origin storage itself.
 * @param {number} id - File link id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} Returned if the request was successful. In the `Location` header is the uri where the client can download the
origin file from the storage.
 */
  async downloadFileLink(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/file_links/{id}/download')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 303,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
 * Gets a collection of all project storages that meet the provided filters and the user has permission to see them.
 * @param {string} [params.filters] - JSON specifying filter conditions.
Accepts the same format as returned by the [queries](https://www.openproject.org/docs/api/endpoints/queries/)
endpoint. Currently supported filters are:

- project_id
- storage_id
- storage_url
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<ProjectStorageCollectionModel>>} OK
 */
  async listProjectStorages(
    params?: ListProjectStoragesParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<ProjectStorageCollectionModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/project_storages')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: projectStorageCollectionModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .build();
    return this.client.call<ProjectStorageCollectionModel>(request);
  }

  /**
   * Gets a project storage resource. This resource contains all data that is applicable on the relation between astorage and a project.
   * @param {number} id - Project storage id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<ProjectStorageModel>>} OK
   */
  async getProjectStorage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<ProjectStorageModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/project_storages/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: projectStorageModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<ProjectStorageModel>(request);
  }

  /**
   * Gets a redirect to the location of the project storage's remote origin. If the project storage has a projectfolder, it is opened at this location. If not, the storage root is opened.
   * @param {number} id - Project storage id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} Redirect
   */
  async openProjectStorage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/project_storages/{id}/open')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 303,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
   * Returns a collection of storages.
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<StorageCollectionModel>>} OK
   */
  async listStorages(requestConfig?: RequestConfig): Promise<HttpResponse<StorageCollectionModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/storages')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: storageCollectionModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .build();
    return this.client.call<StorageCollectionModel>(request);
  }

  /**
 * Creates a storage resource. When creating a storage, a confidential OAuth 2 provider application is createdautomatically. The oauth client id and secret of the created OAuth application are returned in the response.

**IMPORTANT:** This is the only time, the oauth client secret is visible to the consumer. After that, the secret is
hidden.

To update the storage with OAuth client credentials, which enable the storage resource to behave as an OAuth 2
client against an external OAuth 2 provider application, another request must be made to create those, see
`POST /api/v3/storages/{id}/oauth_client_credentials`.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<StorageReadModel>>} Created
 */
  async createStorage(body: StorageWriteModel, requestConfig?: RequestConfig): Promise<HttpResponse<StorageReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/storages')
      .setRequestSchema(storageWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: storageReadModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<StorageReadModel>(request);
  }

  /**
   * Gets a storage resource. As a side effect, a live connection to the storages origin is established to retrieveconnection state data.
   * @param {number} id - Storage id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<StorageReadModel>>} OK
   */
  async getStorage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<StorageReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/storages/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: storageReadModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<StorageReadModel>(request);
  }

  /**
   * Updates a storage resource. Only data that is not generated by the server can be updated. This excludes the OAuth 2application data.
   * @param {number} id - Storage id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<StorageReadModel>>} OK
   */
  async updateStorage(
    id: number,
    body: StorageWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<StorageReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('PATCH')
      .setPath('/api/v3/storages/{id}')
      .setRequestSchema(storageWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: storageReadModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<StorageReadModel>(request);
  }

  /**
   * Deletes a storage resource. This also deletes all related records, like the created oauth application, client, andany file links created within this storage.
   * @param {number} id - Storage id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} No content
   */
  async deleteStorage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('DELETE')
      .setPath('/api/v3/storages/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 204,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
 * Gets a collection of files from a storage.
If no `parent` context is given, the result is the content of the document root. With `parent` context given, the
result contains the collections of files/directories from within the given parent file id.

If given `parent` context is no directory, `400 Bad Request` is returned.
 * @param {number} id - Storage id
 * @param {string} [params.parent] - Parent file identification
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<StorageFilesModel>>} OK
 */
  async getStorageFiles(
    id: number,
    params?: GetStorageFilesParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<StorageFilesModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/storages/{id}/files')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: storageFilesModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'parent',
        value: params?.parent,
      })
      .build();
    return this.client.call<StorageFilesModel>(request);
  }

  /**
 * Executes a request that prepares a link for a direct upload to the storage.
The background here is, that the client needs to make a direct request to the storage instance for file uploading,
but should not get access to the credentials, which are stored in the backend. The response contains a link object,
that enables the client to execute a file upload without the real credentials.
 * @param {number} id - Storage id
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<StorageFileUploadLinkModel>>} OK
 */
  async prepareStorageFileUpload(
    id: number,
    body: StorageFileUploadPreparationModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<StorageFileUploadLinkModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/storages/{id}/files/prepare_upload')
      .setRequestSchema(storageFileUploadPreparationModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: storageFileUploadLinkModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<StorageFileUploadLinkModel>(request);
  }

  /**
   * Creates a new folder under the given parent
   * @param {number} id - Storage id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<StorageFileModel>>} Created
   */
  async createStorageFolder(
    id: number,
    body: StorageFolderWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<StorageFileModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/storages/{id}/folders')
      .setRequestSchema(storageFolderWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: storageFileModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<StorageFileModel>(request);
  }

  /**
   * Inserts the OAuth 2 credentials into the storage, to allow the storage to act as an OAuth 2 client. Calling thisendpoint on a storage that already contains OAuth 2 client credentials will replace them.
   * @param {number} id - Storage id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<StorageReadModel>>} Created
   */
  async createStorageOauthCredentials(
    id: number,
    body: OAuthClientCredentialsWriteModel,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<StorageReadModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/storages/{id}/oauth_client_credentials')
      .setRequestSchema(oAuthClientCredentialsWriteModelRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: storageReadModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<StorageReadModel>(request);
  }

  /**
   * Gets a redirect to the location of the storage's remote origin. The storage's files root should be the targetlocation.
   * @param {number} id - Storage id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} Redirect
   */
  async openStorage(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/storages/{id}/open')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 303,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }
}
