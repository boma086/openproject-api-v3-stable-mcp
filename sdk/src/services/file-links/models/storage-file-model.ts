// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { StorageFileModelType, storageFileModelType } from './storage-file-model-type';
import {
  StorageFileModelLinks,
  storageFileModelLinks,
  storageFileModelLinksRequest,
  storageFileModelLinksResponse,
} from './storage-file-model-links';

/**
 * The shape of the model inside the application code - what the users use
 */
export const storageFileModel = z.lazy(() => {
  return z.object({
    id: z.string(),
    name: z.string(),
    mimeType: z.string().optional(),
    size: z.number().gte(0).optional(),
    createdAt: z.string().optional(),
    lastModifiedAt: z.string().optional(),
    createdByName: z.string().optional(),
    lastModifiedByName: z.string().optional(),
    _type: storageFileModelType,
    location: z.string(),
    _links: storageFileModelLinks,
  });
});

/**
 * 
 * @typedef  {StorageFileModel} storageFileModel   
 * @property {string} - Linked file's id on the origin
 * @property {string} - Linked file's name on the origin
 * @property {string} - MIME type of the linked file.

To link a folder entity, the custom MIME type `application/x-op-directory` MUST be provided. Otherwise it defaults back to
an unknown MIME type.
 * @property {number} - file size on origin in bytes
 * @property {string} - Timestamp of the creation datetime of the file on the origin
 * @property {string} - Timestamp of the datetime of the last modification of the file on the origin
 * @property {string} - Display name of the author that created the file on the origin
 * @property {string} - Display name of the author that modified the file on the origin last
 * @property {StorageFileModelType} 
 * @property {string} - Location identification for file in storage
 * @property {StorageFileModelLinks} 
 */
export type StorageFileModel = z.infer<typeof storageFileModel>;

/**
 * The shape of the model mapping from the api schema into the application shape.
 * Is equal to application shape if all property names match the api schema
 */
export const storageFileModelResponse = z.lazy(() => {
  return z
    .object({
      id: z.string(),
      name: z.string(),
      mimeType: z.string().optional(),
      size: z.number().gte(0).optional(),
      createdAt: z.string().optional(),
      lastModifiedAt: z.string().optional(),
      createdByName: z.string().optional(),
      lastModifiedByName: z.string().optional(),
      _type: storageFileModelType,
      location: z.string(),
      _links: storageFileModelLinksResponse,
    })
    .transform((data) => ({
      id: data['id'],
      name: data['name'],
      mimeType: data['mimeType'],
      size: data['size'],
      createdAt: data['createdAt'],
      lastModifiedAt: data['lastModifiedAt'],
      createdByName: data['createdByName'],
      lastModifiedByName: data['lastModifiedByName'],
      _type: data['_type'],
      location: data['location'],
      _links: data['_links'],
    }));
});

/**
 * The shape of the model mapping from the application shape into the api schema.
 * Is equal to application shape if all property names match the api schema
 */
export const storageFileModelRequest = z.lazy(() => {
  return z
    .object({
      id: z.string(),
      name: z.string(),
      mimeType: z.string().optional(),
      size: z.number().gte(0).optional(),
      createdAt: z.string().optional(),
      lastModifiedAt: z.string().optional(),
      createdByName: z.string().optional(),
      lastModifiedByName: z.string().optional(),
      _type: storageFileModelType,
      location: z.string(),
      _links: storageFileModelLinksRequest,
    })
    .transform((data) => ({
      id: data['id'],
      name: data['name'],
      mimeType: data['mimeType'],
      size: data['size'],
      createdAt: data['createdAt'],
      lastModifiedAt: data['lastModifiedAt'],
      createdByName: data['createdByName'],
      lastModifiedByName: data['lastModifiedByName'],
      _type: data['_type'],
      location: data['location'],
      _links: data['_links'],
    }));
});
