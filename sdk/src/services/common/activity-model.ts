// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { ActivityModelType, activityModelType } from '../activities/models/activity-model-type';
import { Formattable, formattable, formattableRequest, formattableResponse } from './formattable';
import {
  ActivityModelEmbedded,
  activityModelEmbedded,
  activityModelEmbeddedRequest,
  activityModelEmbeddedResponse,
} from '../activities/models/activity-model-embedded';
import {
  ActivityModelLinks,
  activityModelLinks,
  activityModelLinksRequest,
  activityModelLinksResponse,
} from '../activities/models/activity-model-links';

/**
 * The shape of the model inside the application code - what the users use
 */
export const activityModel = z.lazy(() => {
  return z.object({
    _type: activityModelType.optional(),
    id: z.number().gte(1).optional(),
    version: z.number().gte(1).optional(),
    comment: formattable.optional(),
    details: z.array(formattable).optional(),
    internal: z.boolean().optional(),
    createdAt: z.string().optional(),
    updatedAt: z.string().optional(),
    _embedded: activityModelEmbedded.optional(),
    _links: activityModelLinks.optional(),
  });
});

/**
 *
 * @typedef  {ActivityModel} activityModel
 * @property {ActivityModelType}
 * @property {number} - Activity id
 * @property {number} - Activity version
 * @property {Formattable}
 * @property {Formattable[]}
 * @property {boolean} - Whether this activity is internal (only visible to users with view_internal_comments permission)
 * @property {string} - Time of creation
 * @property {string} - Time of update
 * @property {ActivityModelEmbedded}
 * @property {ActivityModelLinks}
 */
export type ActivityModel = z.infer<typeof activityModel>;

/**
 * The shape of the model mapping from the api schema into the application shape.
 * Is equal to application shape if all property names match the api schema
 */
export const activityModelResponse = z.lazy(() => {
  return z
    .object({
      _type: activityModelType.optional(),
      id: z.number().gte(1).optional(),
      version: z.number().gte(1).optional(),
      comment: formattableResponse.optional(),
      details: z.array(formattableResponse).optional(),
      internal: z.boolean().optional(),
      createdAt: z.string().optional(),
      updatedAt: z.string().optional(),
      _embedded: activityModelEmbeddedResponse.optional(),
      _links: activityModelLinksResponse.optional(),
    })
    .transform((data) => ({
      _type: data['_type'],
      id: data['id'],
      version: data['version'],
      comment: data['comment'],
      details: data['details'],
      internal: data['internal'],
      createdAt: data['createdAt'],
      updatedAt: data['updatedAt'],
      _embedded: data['_embedded'],
      _links: data['_links'],
    }));
});

/**
 * The shape of the model mapping from the application shape into the api schema.
 * Is equal to application shape if all property names match the api schema
 */
export const activityModelRequest = z.lazy(() => {
  return z
    .object({
      _type: activityModelType.optional(),
      id: z.number().gte(1).optional(),
      version: z.number().gte(1).optional(),
      comment: formattableRequest.optional(),
      details: z.array(formattableRequest).optional(),
      internal: z.boolean().optional(),
      createdAt: z.string().optional(),
      updatedAt: z.string().optional(),
      _embedded: activityModelEmbeddedRequest.optional(),
      _links: activityModelLinksRequest.optional(),
    })
    .transform((data) => ({
      _type: data['_type'],
      id: data['id'],
      version: data['version'],
      comment: data['comment'],
      details: data['details'],
      internal: data['internal'],
      createdAt: data['createdAt'],
      updatedAt: data['updatedAt'],
      _embedded: data['_embedded'],
      _links: data['_links'],
    }));
});
