// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { BaseService } from '../base-service';
import { ContentType, HttpResponse, RequestConfig } from '../../http/types';
import { RequestBuilder } from '../../http/transport/request-builder';
import { SerializationStyle } from '../../http/serialization/base-serializer';
import { ThrowableError } from '../../http/errors/throwable-error';
import { Environment } from '../../http/environment';
import {
  ListQueriesParams,
  ViewDefaultQueryForProjectParams,
  ViewDefaultQueryParams,
  ViewQueryParams,
} from './request-params';
import { QueryCreateForm, queryCreateFormRequest } from './models/query-create-form';
import { QueryModel, queryModelResponse } from './models/query-model';
import { QueryUpdateForm, queryUpdateFormRequest } from './models/query-update-form';

export class QueriesService extends BaseService {
  /**
 * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query. The query will already be scoped for the project.
 * @param {number} id - Id of the project the default query is requested for
 * @param {string} [params.filters] - JSON specifying filter conditions.
The filters provided as parameters are not applied to the query but are instead used to override the query's persisted filters.
All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (`[]`).
 * @param {number} [params.offset] - Page number inside the queries' result collection of work packages.
 * @param {number} [params.pageSize] - Number of elements to display per page for the queries' result collection of work packages.
 * @param {string} [params.sortBy] - JSON specifying sort criteria. The sort criteria is applied to the query's result collection of work packages overriding the query's persisted sort criteria.
 * @param {string} [params.groupBy] - The column to group by. The grouping criteria is applied to the to the query's result collection of work packages overriding the query's persisted group criteria.
 * @param {boolean} [params.showSums] - Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query's result collection of work packages overriding the query's persisted sums property.
 * @param {string} [params.timestamps] - Indicates the timestamps to filter by when showing changed attributes on work packages. Values can be either ISO8601 dates, ISO8601 durations and the following relative date keywords: "oneDayAgo@HH:MM+HH:MM", "lastWorkingDay@HH:MM+HH:MM", "oneWeekAgo@HH:MM+HH:MM", "oneMonthAgo@HH:MM+HH:MM". The first "HH:MM" part represents the zero paded hours and minutes. The last "+HH:MM" part represents the timezone offset from UTC associated with the time. Values older than 1 day are accepted only with valid Enterprise Token available.

 * @param {boolean} [params.timelineVisible] - Indicates whether the timeline should be shown.
 * @param {boolean} [params.showHierarchies] - Indicates whether the hierarchy mode should be enabled.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async viewDefaultQueryForProject(
    id: number,
    params?: ViewDefaultQueryForProjectParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/projects/{id}/queries/default')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .addQueryParam({
        key: 'offset',
        value: params?.offset,
      })
      .addQueryParam({
        key: 'pageSize',
        value: params?.pageSize,
      })
      .addQueryParam({
        key: 'sortBy',
        value: params?.sortBy,
      })
      .addQueryParam({
        key: 'groupBy',
        value: params?.groupBy,
      })
      .addQueryParam({
        key: 'showSums',
        value: params?.showSums,
      })
      .addQueryParam({
        key: 'timestamps',
        value: params?.timestamps,
      })
      .addQueryParam({
        key: 'timelineVisible',
        value: params?.timelineVisible,
      })
      .addQueryParam({
        key: 'showHierarchies',
        value: params?.showHierarchies,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   * Retrieve the schema for project queries.
   * @param {number} id - Project id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async viewSchemaForProjectQueries(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/projects/{id}/queries/schema')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
 * Returns a collection of queries. The collection can be filtered via query parameters similar to how work packages are filtered. Please note however, that the filters are applied to the queries and not to the work packages the queries in turn might return.
 * @param {string} [params.filters] - JSON specifying filter conditions.
Currently supported filters are:

+ project: filters queries by the project they are assigned to. If the project filter is passed with the `!*` (not any) operator, global queries are returned.

+ id: filters queries based on their id

+ updated_at: filters queries based on the last time they where updated
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async listQueries(params?: ListQueriesParams, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/queries')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
 * When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.The required fields of a Query can be found in its schema, which is embedded in the respective form.
Note that it is only allowed to provide properties or links supporting the write operation.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<QueryModel>>} Created
 */
  async createQuery(body: QueryCreateForm, requestConfig?: RequestConfig): Promise<HttpResponse<QueryModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/queries')
      .setRequestSchema(queryCreateFormRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: queryModelResponse,
        contentType: ContentType.Json,
        status: 201,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<QueryModel>(request);
  }

  /**
   * Gets a list of projects that are available as projects a query can be assigned to.
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async availableProjectsForQuery(requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/queries/available_projects')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .build();
    return this.client.call<any>(request);
  }

  /**
 * Same as [viewing an existing, persisted Query](https://www.openproject.org/docs/api/endpoints/queries/#list-queries) in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query.
 * @param {string} [params.filters] - JSON specifying filter conditions.
The filters provided as parameters are not applied to the query but are instead used to override the query's persisted filters.
All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (`[]`).
 * @param {number} [params.offset] - Page number inside the queries' result collection of work packages.
 * @param {number} [params.pageSize] - Number of elements to display per page for the queries' result collection of work packages.
 * @param {string} [params.sortBy] - JSON specifying sort criteria. The sort criteria is applied to the query's result collection of work packages overriding the query's persisted sort criteria.
 * @param {string} [params.groupBy] - The column to group by. The grouping criteria is applied to the to the query's result collection of work packages overriding the query's persisted group criteria.
 * @param {boolean} [params.showSums] - Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query's result collection of work packages overriding the query's persisted sums property.
 * @param {string} [params.timestamps] - Indicates the timestamps to filter by when showing changed attributes on work packages. Values can be either ISO8601 dates, ISO8601 durations and the following relative date keywords: "oneDayAgo@HH:MM+HH:MM", "lastWorkingDay@HH:MM+HH:MM", "oneWeekAgo@HH:MM+HH:MM", "oneMonthAgo@HH:MM+HH:MM". The first "HH:MM" part represents the zero paded hours and minutes. The last "+HH:MM" part represents the timezone offset from UTC associated with the time, the offset can be positive or negative e.g."oneDayAgo@01:00+01:00", "oneDayAgo@01:00-01:00". Values older than 1 day are accepted only with valid Enterprise Token available.

 * @param {boolean} [params.timelineVisible] - Indicates whether the timeline should be shown.
 * @param {string} [params.timelineZoomLevel] - Indicates in what zoom level the timeline should be shown. Valid values are  `days`, `weeks`, `months`, `quarters`, and `years`.
 * @param {boolean} [params.showHierarchies] - Indicates whether the hierarchy mode should be enabled.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<any>>} OK
 */
  async viewDefaultQuery(params?: ViewDefaultQueryParams, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/queries/default')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .addQueryParam({
        key: 'offset',
        value: params?.offset,
      })
      .addQueryParam({
        key: 'pageSize',
        value: params?.pageSize,
      })
      .addQueryParam({
        key: 'sortBy',
        value: params?.sortBy,
      })
      .addQueryParam({
        key: 'groupBy',
        value: params?.groupBy,
      })
      .addQueryParam({
        key: 'showSums',
        value: params?.showSums,
      })
      .addQueryParam({
        key: 'timestamps',
        value: params?.timestamps,
      })
      .addQueryParam({
        key: 'timelineVisible',
        value: params?.timelineVisible,
      })
      .addQueryParam({
        key: 'timelineZoomLevel',
        value: params?.timelineZoomLevel,
      })
      .addQueryParam({
        key: 'showHierarchies',
        value: params?.showHierarchies,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   *
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async queryCreateForm(body: QueryCreateForm, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/queries/form')
      .setRequestSchema(queryCreateFormRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<void>(request);
  }

  /**
   * Retrieve the schema for global queries, those, that are not assigned to a project.
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async viewSchemaForGlobalQueries(requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/queries/schema')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .build();
    return this.client.call<any>(request);
  }

  /**
 * Retrieve an individual query as identified by the id parameter. Then end point accepts a number of parameters that can be used to override the resources' persisted parameters.
 * @param {number} id - Query id
 * @param {string} [params.filters] - JSON specifying filter conditions.
The filters provided as parameters are not applied to the query but are instead used to override the query's persisted filters.
All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array (`[]`).
 * @param {number} [params.offset] - Page number inside the queries' result collection of work packages.
 * @param {number} [params.pageSize] - Number of elements to display per page for the queries' result collection of work packages.
 * @param {string} [params.columns] - Selected columns for the table view.
 * @param {string} [params.sortBy] - JSON specifying sort criteria. The sort criteria is applied to the query's result collection of work packages overriding the query's persisted sort criteria.
 * @param {string} [params.groupBy] - The column to group by. The grouping criteria is applied to the to the query's result collection of work packages overriding the query's persisted group criteria.
 * @param {boolean} [params.showSums] - Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query's result collection of work packages overriding the query's persisted sums property.
 * @param {string} [params.timestamps] - Indicates the timestamps to filter by when showing changed attributes on work packages. Values can be either ISO8601 dates, ISO8601 durations and the following relative date keywords: "oneDayAgo@HH:MM+HH:MM", "lastWorkingDay@HH:MM+HH:MM", "oneWeekAgo@HH:MM+HH:MM", "oneMonthAgo@HH:MM+HH:MM". The first "HH:MM" part represents the zero paded hours and minutes. The last "+HH:MM" part represents the timezone offset from UTC associated with the time, the offset can be positive or negative e.g."oneDayAgo@01:00+01:00", "oneDayAgo@01:00-01:00". Values older than 1 day are accepted only with valid Enterprise Token available.

 * @param {boolean} [params.timelineVisible] - Indicates whether the timeline should be shown.
 * @param {string} [params.timelineLabels] - Overridden labels in the timeline view
 * @param {string} [params.highlightingMode] - Highlighting mode for the table view.
 * @param {string} [params.highlightedAttributes] - Highlighted attributes mode for the table view when `highlightingMode` is `inline`. When set to `[]` all highlightable attributes will be returned as `highlightedAttributes`.
 * @param {boolean} [params.showHierarchies] - Indicates whether the hierarchy mode should be enabled.
 * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
 * @returns {Promise<HttpResponse<QueryModel>>} OK
 */
  async viewQuery(
    id: number,
    params?: ViewQueryParams,
    requestConfig?: RequestConfig,
  ): Promise<HttpResponse<QueryModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('GET')
      .setPath('/api/v3/queries/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: queryModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addQueryParam({
        key: 'filters',
        value: params?.filters,
      })
      .addQueryParam({
        key: 'offset',
        value: params?.offset,
      })
      .addQueryParam({
        key: 'pageSize',
        value: params?.pageSize,
      })
      .addQueryParam({
        key: 'columns',
        value: params?.columns,
      })
      .addQueryParam({
        key: 'sortBy',
        value: params?.sortBy,
      })
      .addQueryParam({
        key: 'groupBy',
        value: params?.groupBy,
      })
      .addQueryParam({
        key: 'showSums',
        value: params?.showSums,
      })
      .addQueryParam({
        key: 'timestamps',
        value: params?.timestamps,
      })
      .addQueryParam({
        key: 'timelineVisible',
        value: params?.timelineVisible,
      })
      .addQueryParam({
        key: 'timelineLabels',
        value: params?.timelineLabels,
      })
      .addQueryParam({
        key: 'highlightingMode',
        value: params?.highlightingMode,
      })
      .addQueryParam({
        key: 'highlightedAttributes',
        value: params?.highlightedAttributes,
      })
      .addQueryParam({
        key: 'showHierarchies',
        value: params?.showHierarchies,
      })
      .build();
    return this.client.call<QueryModel>(request);
  }

  /**
   * When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body.Note that it is only allowed to provide properties or links supporting the **write** operation.
   * @param {number} id - Query id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<QueryModel>>} OK
   */
  async editQuery(id: number, body: QueryUpdateForm, requestConfig?: RequestConfig): Promise<HttpResponse<QueryModel>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('PATCH')
      .setPath('/api/v3/queries/{id}')
      .setRequestSchema(queryUpdateFormRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: queryModelResponse,
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<QueryModel>(request);
  }

  /**
   * Delete the query identified by the id parameter
   * @param {number} id - Query id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} No Content
   */
  async deleteQuery(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('DELETE')
      .setPath('/api/v3/queries/{id}')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 204,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<void>(request);
  }

  /**
   *
   * @param {number} id - Query id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async queryUpdateForm(id: number, body: QueryUpdateForm, requestConfig?: RequestConfig): Promise<HttpResponse<void>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('POST')
      .setPath('/api/v3/queries/{id}/form')
      .setRequestSchema(queryUpdateFormRequest)
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.undefined(),
        contentType: ContentType.NoContent,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
      .addBody(body)
      .build();
    return this.client.call<void>(request);
  }

  /**
   *
   * @param {number} id - Query id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async starQuery(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('PATCH')
      .setPath('/api/v3/queries/{id}/star')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }

  /**
   *
   * @param {number} id - Query id
   * @param {RequestConfig} requestConfig - (Optional) The request configuration for retry and validation.
   * @returns {Promise<HttpResponse<any>>} OK
   */
  async unstarQuery(id: number, requestConfig?: RequestConfig): Promise<HttpResponse<any>> {
    const request = new RequestBuilder()
      .setBaseUrl(requestConfig?.baseUrl || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
      .setConfig(this.config)
      .setMethod('PATCH')
      .setPath('/api/v3/queries/{id}/unstar')
      .setRequestSchema(z.any())
      .addBasicAuth(this.config.username, this.config.password)
      .addApiKeyAuth(this.config.apiKey, 'api-key-sample')
      .setRequestContentType(ContentType.Json)
      .addResponse({
        schema: z.any(),
        contentType: ContentType.Json,
        status: 200,
      })
      .setRetryAttempts(this.config, requestConfig)
      .setRetryDelayMs(this.config, requestConfig)
      .setResponseValidation(this.config, requestConfig)
      .addPathParam({
        key: 'id',
        value: id,
      })
      .build();
    return this.client.call<any>(request);
  }
}
