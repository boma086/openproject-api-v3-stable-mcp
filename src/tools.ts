// This file was generated by liblab | https://liblab.com/

import { OpenProjectApiV3Stable_, RequestConfig } from 'openproject-api-v3-stable';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { z } from 'zod';

import { onToolCall, onToolSuccess, onToolError } from './hooks.js';

type ApiResponse = {
  content: Array<{
    type: string;
    text: string;
  }>;
  isError?: boolean;
};

interface ListActionsParams {
  filters?: string;
  sortBy?: string;
}

interface ListCapabilitiesParams {
  filters?: string;
  sortBy?: string;
}

interface GetCustomFieldItemsParams {
  parent?: number;
  depth?: number;
}

interface ListNonWorkingDaysParams {
  filters?: string;
}

interface ListDaysParams {
  filters?: string;
}

interface ListDocumentsParams {
  offset?: number;
  pageSize?: number;
  sortBy?: string;
}

interface ViewAggregatedResultParams {
  groupBy?: string;
  showSums?: boolean;
}

interface OpenFileLinkParams {
  location?: boolean;
}

interface ListProjectStoragesParams {
  filters?: string;
}

interface GetStorageFilesParams {
  parent?: string;
}

interface ListGridsParams {
  offset?: number;
  pageSize?: number;
  filters?: string;
}

interface ListGroupsParams {
  sortBy?: string;
  select?: string;
}

interface ListMembershipsParams {
  filters?: string;
  sortBy?: string;
}

interface ListNewsParams {
  offset?: number;
  pageSize?: number;
  sortBy?: string;
  filters?: string;
}

interface ListNotificationsParams {
  offset?: number;
  pageSize?: number;
  sortBy?: string;
  groupBy?: string;
  filters?: string;
}

interface ReadNotificationsParams {
  filters?: string;
}

interface UnreadNotificationsParams {
  filters?: string;
}

interface ListPlaceholderUsersParams {
  filters?: string;
  select?: string;
}

interface ListPrincipalsParams {
  filters?: string;
  select?: string;
}

interface ListProjectsParams {
  filters?: string;
  sortBy?: string;
  select?: string;
}

interface ListAvailableParentProjectCandidatesParams {
  filters?: string;
  of?: string;
  sortBy?: string;
}

interface ViewDefaultQueryForProjectParams {
  filters?: string;
  offset?: number;
  pageSize?: number;
  sortBy?: string;
  groupBy?: string;
  showSums?: boolean;
  timestamps?: string;
  timelineVisible?: boolean;
  showHierarchies?: boolean;
}

interface ListQueriesParams {
  filters?: string;
}

interface ViewDefaultQueryParams {
  filters?: string;
  offset?: number;
  pageSize?: number;
  sortBy?: string;
  groupBy?: string;
  showSums?: boolean;
  timestamps?: string;
  timelineVisible?: boolean;
  timelineZoomLevel?: string;
  showHierarchies?: boolean;
}

interface ViewQueryParams {
  filters?: string;
  offset?: number;
  pageSize?: number;
  columns?: string;
  sortBy?: string;
  groupBy?: string;
  showSums?: boolean;
  timestamps?: string;
  timelineVisible?: boolean;
  timelineLabels?: string;
  highlightingMode?: string;
  highlightedAttributes?: string;
  showHierarchies?: boolean;
}

interface GetProjectWorkPackageCollectionParams {
  offset?: number;
  pageSize?: number;
  filters?: string;
  sortBy?: string;
  groupBy?: string;
  showSums?: boolean;
  select?: string;
}

interface CreateProjectWorkPackageParams {
  notify?: boolean;
}

interface ListWorkPackagesParams {
  offset?: number;
  pageSize?: number;
  filters?: string;
  sortBy?: string;
  groupBy?: string;
  showSums?: boolean;
  select?: string;
  timestamps?: string;
}

interface CreateWorkPackageParams {
  notify?: boolean;
}

interface ListWorkPackageSchemasParams {
  filters: string;
}

interface ViewWorkPackageParams {
  timestamps?: string;
}

interface UpdateWorkPackageParams {
  notify?: boolean;
}

interface CommentWorkPackageParams {
  notify?: boolean;
}

interface ListAvailableRelationCandidatesParams {
  pageSize?: number;
  filters?: string;
  query?: string;
  type?: string;
  sortBy?: string;
}

interface ListWorkPackageFileLinksParams {
  filters?: string;
}

interface ListVersionsParams {
  filters?: string;
  sortBy?: string;
}

interface ListRelationsParams {
  filters?: string;
  sortBy?: string;
}

interface PreviewMarkdownDocumentParams {
  context?: string;
}

interface ListRolesParams {
  filters?: string;
}

interface ListTimeEntriesParams {
  offset?: number;
  pageSize?: number;
  sortBy?: string;
  filters?: string;
}

interface ListUsersParams {
  offset?: number;
  pageSize?: number;
  filters?: string;
  sortBy?: string;
  select?: string;
}

interface ListViewsParams {
  filters?: string;
}

/**
 * Formats an error into a standardized API response.
 *
 * @param {Error} error - The error object to format.
 * @returns {ApiResponse} The formatted error response with a message.
 */
function formatErrorResponse(error: Error): ApiResponse {
  return {
    content: [
      {
        type: 'text',
        text: `Error: ${error.message || 'Unknown error'}`,
      },
    ],
    isError: true,
  };
}

/**
 * Formats successful data into a standardized API response.
 *
 * @param {*} data - The data to include in the response. Can be an object, string, number, etc.
 * @returns {ApiResponse} The formatted success response.
 */
function formatSuccessResponse(data: any): ApiResponse {
  let text: string;

  if (typeof data === 'object') {
    text = JSON.stringify(data, null, 2);
  } else {
    text = String(data);
  }

  return {
    content: [
      {
        type: 'text',
        text,
      },
    ],
  };
}

/**
 * Attempts to parse a string as JSON, returning the parsed object if valid.
 *
 * @param {any} value - The value to parse.
 * @returns {any} Parsed object if valid JSON, otherwise the original value.
 */
function tryParseJSON(value: string): any {
  if (typeof value !== 'string') return value;
  try {
    const parsed = JSON.parse(value);
    if (typeof parsed === 'object' && parsed !== null) {
      return parsed;
    }
  } catch (e) {}
  return value;
}

/**
 * Replaces all `process.env.KEY` occurrences in a string with actual env values.
 *
 * @param {string} str - The input string.
 * @returns {string} The string with env values injected.
 */
const replaceEnvInString = (str: string): string => {
  for (const [envKey, envValue] of Object.entries(process.env)) {
    str = str.replaceAll(`process.env.${envKey}`, envValue || '');
  }
  return str;
};

/**
 * Replaces environment variable references in a value.
 *
 * @param {any} value - The value to process.
 * @returns {any} Processed value with env values injected.
 */
const replaceEnvInValue = (value: any): any => {
  if (typeof value === 'string') {
    return tryParseJSON(replaceEnvInString(value));
  } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
    const stringified = JSON.stringify(value);
    const replaced = replaceEnvInString(stringified);
    return JSON.parse(replaced);
  }
  return value;
};

/**
 * Wraps a handler to inject environment variables into its params.
 *
 * @param {Function} handler - The function to wrap.
 * @returns {Function} Wrapped function with env-injected arguments.
 */
function parseParams(handler: any): any {
  return (args: any) => {
    if (!args || typeof args !== 'object') return handler(args);

    const result: Record<string, any> = {};
    for (const [key, value] of Object.entries(args)) {
      result[key] = replaceEnvInValue(value);
    }

    return handler(result);
  };
}

const RequestConfigSchema = z
  .object({
    retry: z
      .object({
        attempts: z.number().describe('Number of times a request should be retried upon failure'),
        delayMs: z.number().optional().describe('Delay in milliseconds between retry attempts'),
      })
      .optional()
      .describe('Configuration for request retry behavior'),

    validation: z
      .object({
        responseValidation: z
          .boolean()
          .optional()
          .describe('Whether the response should be validated against a schema'),
      })
      .optional()
      .describe('Settings related to request and response validation'),

    baseUrl: z.string().optional().describe('Base URL for the API requests'),
  })
  .optional()
  .describe('Configuration object for customizing request behavior');

/**
 * Creates a standardized API tool with consistent error handling and response formatting.
 *
 * @param server - The MCP server instance
 * @param name - The tool name
 * @param description - The tool description
 * @param schema - The Zod schema for validation
 * @param handler - The handler function that calls the SDK
 */
function createApiTool<T>(
  server: McpServer,
  name: string,
  description: string,
  schema: any,
  handler: (args: T) => Promise<any>,
): void {
  server.tool(
    name,
    description,
    schema,
    parseParams(async (args: T): Promise<ApiResponse> => {
      onToolCall(name);
      try {
        const result = await handler(args);
        onToolSuccess(name);
        return formatSuccessResponse(result);
      } catch (error) {
        const normalizedError = error instanceof Error ? error : new Error(String(error));
        onToolError(name, normalizedError);
        return formatErrorResponse(normalizedError);
      }
    }),
  );
}

export function setupTools(server: McpServer, sdk: OpenProjectApiV3Stable_) {
  // Root Service

  createApiTool(
    server,
    'view_root',
    'Returns the root resource, containing basic information about the server instance and a collection of useful links.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.root.viewRoot(args.requestConfig);
      return data;
    },
  );
  // Actions & Capabilities Service

  createApiTool(
    server,
    'list_actions',
    'Returns a collection of actions. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  id Returns only the action having the id or all actions except those having the ids.',
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported sorts are  No sort supported yet',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListActionsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.actionsCapabilities.listActions(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_action',
    'Returns an individual action.',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.actionsCapabilities.viewAction(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_capabilities',
    'Returns a collection of actions assigned to a principal in a context. The client can choose to filter the actions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain actions, for which the requesting client has sufficient permissions',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint.  action Get all capabilities of a certain action  principal Get all capabilities of a principal  context Get all capabilities within a context. Note that for a project context the client needs to provide pid, e.g. p5 and for the global context a g',
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported sorts are  id Sort by the capabilities id',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListCapabilitiesParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.actionsCapabilities.listCapabilities(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_global_context',
    'Returns the global capability context. This context is necessary to consistently link to a context even if the context is not a project.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.actionsCapabilities.viewGlobalContext(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_capabilities',
    'View capabilities',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.actionsCapabilities.viewCapabilities(args.id, args.requestConfig);
      return data;
    },
  );
  // Activities Service

  createApiTool(
    server,
    'get_activity',
    'Returns the requested activity resource identified by its unique id.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.activities.getActivity(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_activity',
    "Updates an activity's comment and, on success, returns the updated activity.",
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.activities.updateActivity(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_activity_attachments',
    'List all attachments of a single activity.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.activities.listActivityAttachments(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_activity_attachment',
    'Adds an attachment to the specified activity.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.activities.createActivityAttachment(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );
  // Attachments Service

  createApiTool(
    server,
    'create_attachment',
    'Clients can create attachments without a container first and attach them later on. This is useful if the container does not exist at the time the attachment is uploaded. After the upload, the client can then claim such containerless attachments for any resource eligible e.g. WorkPackage on subsequent requests. The upload and the claiming must be done for the same user account. Attachments uploaded by another user cannot be claimed and once claimed for a resource, they cannot be claimed by another. The upload request must be of type multipartform-data with exactly two parts. The first part must be called metadata. Its content type is expected to be applicationjson, the body must be a single JSON object, containing at least the fileName and optionally the attachments description. The second part must be called file, its content type should match the mime type of the file. The body must be the raw content of the file. Note that a filename must be indicated in the Content-Disposition of this part, although it will be ignored. Instead the fileName inside the JSON of the metadata part will be used.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.createAttachment(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_attachment',
    'View attachment',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.viewAttachment(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_attachment',
    'Permanently deletes the specified attachment.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.deleteAttachment(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_attachments_by_meeting',
    'List attachments by meeting',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.listAttachmentsByMeeting(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'add_attachment_to_meeting',
    'Adds an attachment with the meeting as its container.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.addAttachmentToMeeting(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_attachments_by_post',
    'List attachments by post',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.listAttachmentsByPost(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'add_attachment_to_post',
    'Adds an attachment with the post as its container.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.addAttachmentToPost(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_attachments_by_wiki_page',
    'List attachments by wiki page',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.listAttachmentsByWikiPage(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'add_attachment_to_wiki_page',
    'Adds an attachment with the wiki page as its container.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.addAttachmentToWikiPage(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_work_package_attachments',
    'List attachments by work package',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.listWorkPackageAttachments(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_work_package_attachment',
    'To add an attachment to a work package, a client needs to issue a request of type multipartform-data with exactly two parts. The first part must be called metadata. Its content type is expected to be applicationjson, the body must be a single JSON object, containing at least the fileName and optionally the attachments description. The second part must be called file, its content type should match the mime type of the file. The body must be the raw content of the file. Note that a filename must be indicated in the Content-Disposition of this part, however it will be ignored. Instead the fileName inside the JSON of the metadata part will be used.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.attachments.createWorkPackageAttachment(args.id, args.requestConfig);
      return data;
    },
  );
  // Budgets Service

  createApiTool(
    server,
    'view_budget',
    'view Budget',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.budgets.viewBudget(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_budgets_of_a_project',
    'view Budgets of a Project',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.budgets.viewBudgetsOfAProject(args.id, args.requestConfig);
      return data;
    },
  );
  // Categories Service

  createApiTool(
    server,
    'view_category',
    'View Category',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.categories.viewCategory(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_categories_of_a_project',
    'List categories of a project',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.categories.listCategoriesOfAProject(args.id, args.requestConfig);
      return data;
    },
  );
  // Configuration Service

  createApiTool(
    server,
    'view_configuration',
    'View configuration',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.configuration.viewConfiguration(args.requestConfig);
      return data;
    },
  );
  // Custom actions Service

  createApiTool(
    server,
    'get_custom_action',
    'Retrieves a custom action by id.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.customActions.getCustomAction(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'execute_custom_action',
    "A POST to this end point executes the custom action on the work package provided in the payload. The altered work package will be returned. In order to avoid executing  the custom action unbeknown to a change that has already taken place, the client has to provide the work package's current lockVersion.",
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.customActions.executeCustomAction(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );
  // api Service

  createApiTool(
    server,
    'get_custom_field_items',
    'Retrieves the hierarchy of custom fields. The hierarchy is a tree structure of hierarchy items. It is represented as a flat list of items, where each item has a reference to its parent and children. The list is ordered in a depth-first manner. The first item is the requested parent. If parent was unset, the root item is returned as first element. Passing the depth query parameter allows to limit the depth of the hierarchy. If the depth is unset, the full hierarchy tree is returned. If the depth is set to 0, only the requested parent is returned. Any other positive integer will return the number of children levels specified by this value. This endpoint only returns, if the custom field is of type hierarchy.',
    {
      id: z.number(),
      params: z
        .object({
          parent: z.number().optional().describe('The identifier of the parent hierarchy item'),
          depth: z.number().optional().describe('The level of hierarchy depth'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; params?: GetCustomFieldItemsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.api.getCustomFieldItems(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_custom_field_item',
    'Retrieves a single custom field item specified by its unique identifier.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.api.getCustomFieldItem(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_custom_field_item_branch',
    'Retrieves the branch of a single custom field item specified by its unique identifier. A branch is list of all ancestors, starting with the root item and finishing with the item itself.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.api.getCustomFieldItemBranch(args.id, args.requestConfig);
      return data;
    },
  );
  // Custom Options Service

  createApiTool(
    server,
    'view_custom_option',
    'View Custom Option',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.customOptions.viewCustomOption(args.id, args.requestConfig);
      return data;
    },
  );
  // Work Schedule Service

  createApiTool(
    server,
    'list_non_working_days',
    'Lists all one-time non working days, such as holidays. It does not lists the non working weekdays, such as each Saturday, Sunday. For listing the weekends, the apiv3days endpoint should be used. All days from current year are returned by default.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  date the inclusive date interval to scope days to look up. When   unspecified, default is from the beginning to the end of current year.   Example  "date"  "operator" "d", "values" "2022-05-02","2022-05-26"     would return days between May 5 and May 26 2022, inclusive.',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListNonWorkingDaysParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.listNonWorkingDays(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_non_working_day',
    'NOT IMPLEMENTED Marks a day as being a non-working day. Note creating a non-working day will not affect the start and finish dates of work packages but will affect their duration.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.createNonWorkingDay(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_non_working_day',
    'Returns the non-working day information for a given date.',
    {
      date: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { date: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.viewNonWorkingDay(args.date, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_non_working_day',
    'NOT IMPLEMENTED Update the non-working day information for a given date.',
    {
      date: z.string(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { date: string; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.updateNonWorkingDay(args.date, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_non_working_day',
    'NOT IMPLEMENTED Removes the non-working day at the given date. Note deleting a non-working day will not affect the start and finish dates of work packages but will affect their duration.',
    {
      date: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { date: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.deleteNonWorkingDay(args.date, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_week_days',
    'Lists week days with work schedule information.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.listWeekDays(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_week_days',
    'NOT IMPLEMENTED Update multiple week days with work schedule information.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.updateWeekDays(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_week_day',
    'View a week day and its attributes.',
    {
      day: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { day: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.viewWeekDay(args.day, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_week_day',
    'NOT IMPLEMENTED Makes a week day a working or non-working day. Note changing a week day working attribute will not affect the start and finish dates of work packages but will affect their duration attribute.',
    {
      day: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { day: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.updateWeekDay(args.day, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_days',
    'Lists days information for a given date interval. All days from the beginning of current month to the end of following month are returned by default.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  date the inclusive date interval to scope days to look up. When   unspecified, default is from the beginning of current month to the end   of following month.   Example  "date"  "operator" "d", "values" "2022-05-02","2022-05-26"     would return days between May 5 and May 26 2022, inclusive.  working when true, returns only the working days. When false,   returns only the non-working days weekend days and non-working days.   When unspecified, returns both working and non-working days.   Example  "working"  "operator" "", "values" "t"     would exclude non-working days from the response.',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListDaysParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.listDays(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_day',
    'View the day information for a given date.',
    {
      date: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { date: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workSchedule.viewDay(args.date, args.requestConfig);
      return data;
    },
  );
  // Documents Service

  createApiTool(
    server,
    'list_documents',
    "The documents returned depend on the provided parameters and also on the requesting user's permissions.",
    {
      params: z
        .object({
          offset: z.number().optional().describe('Page number inside the requested collection.'),
          pageSize: z.number().optional().describe('Number of elements to display per page.'),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported sorts are  id Sort by primary key  createdat Sort by document creation datetime',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListDocumentsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.documents.listDocuments(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_document',
    'View document',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.documents.viewDocument(args.id, args.requestConfig);
      return data;
    },
  );
  // Forms Service

  createApiTool(
    server,
    'show_or_validate_form',
    'This is an example of how a form might look like. Note that this endpoint does not exist in the actual implementation.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.forms.showOrValidateForm(args.body || {}, args.requestConfig);
      return data;
    },
  );
  // Schemas Service

  createApiTool(
    server,
    'view_the_schema',
    'This is an example of how a schema might look like. Note that this endpoint does not exist in the actual implementation.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.schemas.viewTheSchema(args.requestConfig);
      return data;
    },
  );
  // Collections Service

  createApiTool(
    server,
    'view_aggregated_result',
    'view aggregated result',
    {
      params: z
        .object({
          groupBy: z
            .string()
            .optional()
            .describe(
              'The column to group by. Note Aggregation is as of now only supported by the work package collection. You can pass any column name as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint.',
            ),
          showSums: z.boolean().optional().describe('showSums'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ViewAggregatedResultParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.collections.viewAggregatedResult(args.params, args.requestConfig);
      return data;
    },
  );
  // File links Service

  createApiTool(
    server,
    'view_file_link',
    'Gets a single file link resource of a work package.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.viewFileLink(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_file_link',
    'Removes a file link on a work package. The request contains only the file link identifier as a path parameter. No request body is needed.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.deleteFileLink(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'open_file_link',
    'Creates a uri to open the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.',
    {
      id: z.number(),
      params: z
        .object({
          location: z
            .boolean()
            .optional()
            .describe(
              'Boolean flag indicating, if the file should be opened directly or rather the directory location.',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; params?: OpenFileLinkParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.openFileLink(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'download_file_link',
    'Creates a uri to download the origin file linked by the given file link. This uri depends on the storage type and is always located on the origin storage itself.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.downloadFileLink(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_project_storages',
    'Gets a collection of all project storages that meet the provided filters and the user has permission to see them.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are - projectid - storageid - storageurl',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListProjectStoragesParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.listProjectStorages(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_project_storage',
    'Gets a project storage resource. This resource contains all data that is applicable on the relation between a storage and a project.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.getProjectStorage(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'open_project_storage',
    "Gets a redirect to the location of the project storage's remote origin. If the project storage has a project folder, it is opened at this location. If not, the storage root is opened.",
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.openProjectStorage(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_storages',
    'Returns a collection of storages.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.listStorages(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_storage',
    'Creates a storage resource. When creating a storage, a confidential OAuth 2 provider application is created automatically. The oauth client id and secret of the created OAuth application are returned in the response. IMPORTANT This is the only time, the oauth client secret is visible to the consumer. After that, the secret is hidden. To update the storage with OAuth client credentials, which enable the storage resource to behave as an OAuth 2 client against an external OAuth 2 provider application, another request must be made to create those, see POST apiv3storagesidoauthclientcredentials.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.createStorage(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_storage',
    'Gets a storage resource. As a side effect, a live connection to the storages origin is established to retrieve connection state data.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.getStorage(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_storage',
    'Updates a storage resource. Only data that is not generated by the server can be updated. This excludes the OAuth 2 application data.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.updateStorage(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_storage',
    'Deletes a storage resource. This also deletes all related records, like the created oauth application, client, and any file links created within this storage.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.deleteStorage(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_storage_files',
    'Gets a collection of files from a storage. If no parent context is given, the result is the content of the document root. With parent context given, the result contains the collections of filesdirectories from within the given parent file id. If given parent context is no directory, 400 Bad Request is returned.',
    {
      id: z.number(),
      params: z
        .object({
          parent: z.string().optional().describe('Parent file identification'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; params?: GetStorageFilesParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.getStorageFiles(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'prepare_storage_file_upload',
    'Executes a request that prepares a link for a direct upload to the storage. The background here is, that the client needs to make a direct request to the storage instance for file uploading, but should not get access to the credentials, which are stored in the backend. The response contains a link object, that enables the client to execute a file upload without the real credentials.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.prepareStorageFileUpload(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_storage_folder',
    'Creates a new folder under the given parent',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.createStorageFolder(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_storage_oauth_credentials',
    'Inserts the OAuth 2 credentials into the storage, to allow the storage to act as an OAuth 2 client. Calling this endpoint on a storage that already contains OAuth 2 client credentials will replace them.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.createStorageOauthCredentials(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'open_storage',
    "Gets a redirect to the location of the storage's remote origin. The storage's files root should be the target location.",
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.fileLinks.openStorage(args.id, args.requestConfig);
      return data;
    },
  );
  // Grids Service

  createApiTool(
    server,
    'list_grids',
    'Lists all grids matching the provided filters and being part of the selected query page. The grids returned will also depend on the permissions of the requesting user.',
    {
      params: z
        .object({
          offset: z.number().optional().describe('Page number inside the requested collection.'),
          pageSize: z.number().optional().describe('Number of elements to display per page.'),
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are - page Filter grid by work package',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListGridsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.grids.listGrids(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_grid',
    'Creates a new grid applying the attributes provided in the body. The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to create a grid.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.grids.createGrid(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'grid_create_form',
    'Grid Create Form',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.grids.gridCreateForm(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_grid',
    'Fetches a single grid identified by its id.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.grids.getGrid(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_grid',
    'Updates the given grid by applying the attributes provided in the body. The constraints applied to the grid depend on the page the grid is placed in which is why the create form end point should be used to be guided when wanting to update a grid.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.grids.updateGrid(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'grid_update_form',
    'Grid Update Form',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.grids.gridUpdateForm(args.id, args.requestConfig);
      return data;
    },
  );
  // Groups Service

  createApiTool(
    server,
    'list_groups',
    'Returns a collection of groups. The client can choose to filter the groups similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain groups, for which the requesting client has sufficient permissions viewmembers, managemembers.',
    {
      params: z
        .object({
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported sorts are  id Sort by primary key  createdat Sort by group creation datetime  updatedat Sort by the time the group was updated last',
            ),
          select: z.string().optional().describe('Comma separated list of properties to include.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListGroupsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.groups.listGroups(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_group',
    'Creates a new group applying the attributes provided in the body.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.groups.createGroup(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_group',
    'Fetches a group resource.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.groups.getGroup(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_group',
    'Updates the given group by applying the attributes provided in the body. Please note that the members array provided will override the existing set of members similar to a PUT. A client thus has to provide the complete list of members the group is to have after the PATCH even if only one member is to be added.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.groups.updateGroup(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_group',
    'Deletes the group.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.groups.deleteGroup(args.id, args.requestConfig);
      return data;
    },
  );
  // Help texts Service

  createApiTool(
    server,
    'list_help_texts',
    'List the complete collection of help texts.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.helpTexts.listHelpTexts(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_help_text',
    'Fetches the help text from the given id.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.helpTexts.getHelpText(args.id, args.requestConfig);
      return data;
    },
  );
  // Meetings Service

  createApiTool(
    server,
    'view_meeting',
    'Retrieve an individual meeting as identified by the id parameter',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.meetings.viewMeeting(args.id, args.requestConfig);
      return data;
    },
  );
  // Memberships Service

  createApiTool(
    server,
    'list_memberships',
    'Returns a collection of memberships. The client can choose to filter the memberships similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain memberships, for which the requesting client has sufficient permissions viewmembers, managemembers.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  anynameattribute filters memberships based on the name of the principal. All possible name variants   and also email and login are searched.  blocked reduces the result set to all memberships that are temporarily blocked or that are not blocked   temporarily.  group filters memberships based on the name of a group. The group however is not the principal used for   filtering. Rather, the memberships of the group are used as the filter values.  name filters memberships based on the name of the principal. Note that only the name is used which depends   on a setting in the OpenProject instance.  principal filters memberships based on the id of the principal.  project filters memberships based on the id of the project.  role filters memberships based on the id of any role assigned to the membership.  status filters memberships based on the status of the principal.  createdat filters memberships based on the time the membership was created.  updatedat filters memberships based on the time the membership was updated last.',
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported sorts are  id Sort by primary key  name Sort by the name of the principal. Note that this depends on the setting for how the name is to be   displayed at least for users.  email Sort by the email address of the principal. Groups and principal users, which do not have an email,   are sorted last.  status Sort by the status of the principal. Groups and principal users, which do not have a status, are   sorted together with the active users.  createdat Sort by membership creation datetime  updatedat Sort by the time the membership was updated last',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListMembershipsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.listMemberships(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_membership',
    'Creates a new membership applying the attributes provided in the body. You can use the form and schema to retrieve the valid attribute values and by that be guided towards successful creation. By providing a notificationMessage within the meta block of the payload, the client can include a customized message to the user of the newly created membership. In case of a group, the message will be sent to every user belonging to the group. By including  "sendNotifications" false  within the meta block of the payload, no notifications is send out at all.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.createMembership(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_memberships_available_projects',
    'Gets a list of projects in which a membership can be created in. The list contains all projects in which the user issuing the request has the manage members permissions.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.getMembershipsAvailableProjects(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'form_create_membership',
    'Requests and validates the creation form for memberships. The request payload, if sent, is validated. The form endpoint itself does not create a membership.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.formCreateMembership(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_membership_schema',
    'Retrieves the schema for the membership resource object.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.getMembershipSchema(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_membership',
    'Retrieves a membership resource identified by the given id.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.getMembership(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_membership',
    'Updates the given membership by applying the attributes provided in the body. By providing a notificationMessage within the meta block of the payload, the client can include a customized message to the user of the updated membership. In case of a group, the message will be sent to every user belonging to the group. By including  "sendNotifications" false  within the meta block of the payload, no notifications is send out at all.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.updateMembership(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_membership',
    'Deletes the membership.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.deleteMembership(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'form_update_membership',
    'Requests and validates the update form for a membership identified by the given id. The request payload, if sent, is validated. The form endpoint itself does not change the membership.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.memberships.formUpdateMembership(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );
  // UserPreferences Service

  createApiTool(
    server,
    'show_my_preferences',
    'Show my preferences',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.userPreferences.showMyPreferences(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_user_preferences',
    'When calling this endpoint the client provides a single object, containing the properties that it wants to change, in the body.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.userPreferences.updateUserPreferences(args.body || {}, args.requestConfig);
      return data;
    },
  );
  // News Service

  createApiTool(
    server,
    'list_news',
    "Lists news. The news returned depend on the provided parameters and also on the requesting user's permissions.",
    {
      params: z
        .object({
          offset: z.number().optional().describe('Page number inside the requested collection.'),
          pageSize: z.number().optional().describe('Number of elements to display per page.'),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported sorts are  id Sort by primary key  createdat Sort by news creation datetime',
            ),
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  projectid Filter news by project',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListNewsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.news.listNews(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_news',
    'Creates a news entry. Only administrators and users with "Manage news" permission in the given project are eligible. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.news.createNews(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_news',
    'View news',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.news.viewNews(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_news',
    "Updates the news's writable attributes. When calling this endpoint the client provides a single object, containing the properties and links to be updated, in the body.",
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.news.updateNews(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_news',
    'Permanently deletes the specified news entry.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.news.deleteNews(args.id, args.requestConfig);
      return data;
    },
  );
  // Notifications Service

  createApiTool(
    server,
    'list_notifications',
    "Returns the collection of available in-app notifications. The notifications returned depend on the provided parameters and also on the requesting user's permissions. Contrary to most collections, this one also links to and embeds schemas for the details properties of the notifications returned. This is an optimization. Clients will receive the information necessary to display the various types of details that a notification can carry.",
    {
      params: z
        .object({
          offset: z.number().optional().describe('Page number inside the requested collection.'),
          pageSize: z.number().optional().describe('Number of elements to display per page.'),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported sorts are  id Sort by primary key  reason Sort by notification reason  readIAN Sort by read status',
            ),
          groupBy: z
            .string()
            .optional()
            .describe(
              'string specifying groupby criteria.  reason Group by notification reason  project Sort by associated project',
            ),
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  id Filter by primary key  project Filter by the project the notification was created in  readIAN Filter by read status  reason Filter by the reason, e.g. 'mentioned' or 'assigned' the notification was created because of  resourceId Filter by the id of the resource the notification was created for. Ideally used together with the resourceType filter.  resourceType Filter by the type of the resource the notification was created for. Ideally used together with the resourceId filter.",
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListNotificationsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.notifications.listNotifications(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'read_notifications',
    'Marks the whole notification collection as read. The collection contains only elements the authenticated user can see, and can be further reduced with filters.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  id Filter by primary key  project Filter by the project the notification was created in  reason Filter by the reason, e.g. 'mentioned' or 'assigned' the notification was created because of  resourceId Filter by the id of the resource the notification was created for. Ideally used together with the   resourceType filter.  resourceType Filter by the type of the resource the notification was created for. Ideally used together with   the resourceId filter.",
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ReadNotificationsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.notifications.readNotifications(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'unread_notifications',
    'Marks the whole notification collection as unread. The collection contains only elements the authenticated user can see, and can be further reduced with filters.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  id Filter by primary key  project Filter by the project the notification was created in  reason Filter by the reason, e.g. 'mentioned' or 'assigned' the notification was created because of  resourceId Filter by the id of the resource the notification was created for. Ideally used together with the   resourceType filter.  resourceType Filter by the type of the resource the notification was created for. Ideally used together with   the resourceId filter.",
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: UnreadNotificationsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.notifications.unreadNotifications(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_notification',
    'Returns the notification identified by the notification id.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.notifications.viewNotification(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_notification_detail',
    'Returns an individual detail of a notification identified by the notification id and the id of the detail.',
    {
      notificationId: z.number(),
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { notificationId: number; id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.notifications.viewNotificationDetail(args.notificationId, args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'read_notification',
    'Marks the given notification as read.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.notifications.readNotification(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'unread_notification',
    'Marks the given notification as unread.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.notifications.unreadNotification(args.id, args.requestConfig);
      return data;
    },
  );
  // OAuth 2 Service

  createApiTool(
    server,
    'get_oauth_application',
    'Retrieves the OAuth 2 provider application for the given identifier. The secret will not be part of the response, instead a confidential flag is indicating, whether there is a secret or not.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.oAuth2.getOauthApplication(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_oauth_client_credentials',
    'Retrieves the OAuth 2 client credentials for the given identifier. The secret will not be part of the response, instead a confidential flag is indicating, whether there is a secret or not.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.oAuth2.getOauthClientCredentials(args.id, args.requestConfig);
      return data;
    },
  );
  // Principals Service

  createApiTool(
    server,
    'list_placeholder_users',
    'List all placeholder users. This can only be accessed if the requesting user has the global permission manageplaceholderuser or managemembers in any project.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are - name filters placeholder users by the name. - group filters placeholder by the group it is contained in. - status filters placeholder by the status it has.',
            ),
          select: z.string().optional().describe('Comma separated list of properties to include.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListPlaceholderUsersParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.principals.listPlaceholderUsers(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_placeholder_user',
    'Creates a new placeholder user. Only administrators and users with manageplaceholderuser global permission are allowed to do so. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.principals.createPlaceholderUser(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_placeholder_user',
    'Return the placeholder user resource.',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.principals.viewPlaceholderUser(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_placeholder_user',
    "Updates the placeholder user's writable attributes. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.",
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.principals.updatePlaceholderUser(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_placeholder_user',
    'Set the specified placeholder user to deleted status.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.principals.deletePlaceholderUser(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_principals',
    'List all principals. The client can choose to filter the principals similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain principals who are members in projects the client is allowed to see.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are - type filters principals by their type User, Group, PlaceholderUser. - member filters principals by the projects they are members in. - name filters principals by the user or group name. - anynameattribute filters principals by the user or group first- and last name, email or login. - status filters principals by their status number active  1, registered  2, locked  3, invited  4',
            ),
          select: z.string().optional().describe('Comma separated list of properties to include.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListPrincipalsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.principals.listPrincipals(args.params, args.requestConfig);
      return data;
    },
  );
  // Posts Service

  createApiTool(
    server,
    'view_post',
    'Retrieve an individual post as identified by the id parameter',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.posts.viewPost(args.id, args.requestConfig);
      return data;
    },
  );
  // Priorities Service

  createApiTool(
    server,
    'list_all_priorities',
    'List all Priorities',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.priorities.listAllPriorities(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_priority',
    'View Priority',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.priorities.viewPriority(args.id, args.requestConfig);
      return data;
    },
  );
  // Projects Service

  createApiTool(
    server,
    'list_projects',
    'Returns a collection of projects. The collection can be filtered via query parameters similar to how work packages are filtered. In addition to the provided filter, the result set is always limited to only contain projects the client is allowed to see.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  active based on the active property of the project  ancestor filters projects by their ancestor. A project is not considered to be its own ancestor.  availableprojectattributes filters projects based on the activated project project attributes.  createdat based on the time the project was created  id based on projects' id.  latestactivityat based on the time the last activity was registered on a project.  projectphaseany based on the project phases active in a project.  nameandidentifier based on both the name and the identifier.  parentid filters projects by their parent.  principal based on members of the project.  storageid filters projects by linked storages  storageurl filters projects by linked storages identified by the host url  typeid based on the types active in a project.  useraction based on the actions the current user has in the project.  visible based on the visibility for the user id provided as the filter value. This filter is useful for admins to identify the projects visible to a user. There might also be additional filters based on the custom fields that have been configured. Each defined lifecycle step will also define a filter in this list endpoint. Given that the elements are not static but rather dynamically created on each OpenProject instance, a list cannot be provided. Those filters follow the schema  projectstartgateid a filter on a project phase's start gate active in a project. The id is the id of the phase the gate belongs to.  projectfinishgateid a filter on a project phase's finish gate active in a project. The id is the id of the phase the gate belongs to.  projectphaseid a filter on a project phase active in a project. The id is the id of the phase queried for.",
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Currently supported orders are  id  name  typeahead sorting by hierarchy and name  createdat  public  latestactivityat  requireddiskspace There might also be additional orders based on the custom fields that have been configured.',
            ),
          select: z.string().optional().describe('Comma separated list of properties to include.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListProjectsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.listProjects(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_project',
    'Creates a new project, applying the attributes provided in the body. You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.createProject(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'project_create_form',
    'Project create form',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.projectCreateForm(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_project_schema',
    'View project schema',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.viewProjectSchema(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_project',
    'View project',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.viewProject(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_project',
    'Updates the given project by applying the attributes provided in the body.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.updateProject(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_project',
    'Deletes the project permanently. As this is a lengthy process, the actual deletion is carried out asynchronously. So the project might exist well after the request has returned successfully. To prevent unwanted changes to the project scheduled for deletion, it is archived at once.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.deleteProject(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'project_update_form',
    'Project update form',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.projectUpdateForm(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_project_copy',
    'Create project copy',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.createProjectCopy(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'project_copy_form',
    'Project copy form',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.projectCopyForm(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_project_status',
    'View project status',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.viewProjectStatus(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_available_parent_project_candidates',
    'Lists projects which can become parent to another project. Only sound candidates are returned. For instance a project cannot become parent of itself or its children. To specify the project for which a parent is queried for, the of parameter can be provided. If no of parameter is provided, a new project is assumed. Then, the check for the hierarchy is omitted as a new project cannot be part of a hierarchy yet. Candidates can be filtered. Most commonly one will want to filter by name or identifier. You can do this through the filters parameter which works just like the work package index. For instance to find all parent candidates with "rollout" in their name  filters"nameandidentifier""operator""","values""rollout"',
    {
      params: z
        .object({
          filters: z.string().optional().describe('JSON specifying filter conditions.'),
          of: z
            .string()
            .optional()
            .describe('The id or identifier of the project the parent candidate is determined for'),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint and allows all the filters and sortBy supported by the project list end point.',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: {
      params?: ListAvailableParentProjectCandidatesParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      const { data } = await sdk.projects.listAvailableParentProjectCandidates(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_projects_with_version',
    'This endpoint lists the projects where the given version is available. The projects returned depend on the sharing settings of the given version, but are also limited to the projects that the current user is allowed to see.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.projects.listProjectsWithVersion(args.id, args.requestConfig);
      return data;
    },
  );
  // Queries Service

  createApiTool(
    server,
    'view_default_query_for_project',
    'Same as viewing an existing, persisted Queryhttpswww.openproject.orgdocsapiendpointsquerieslist-queries in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query. The query will already be scoped for the project.',
    {
      id: z.number(),
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query's persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array .",
            ),
          offset: z.number().optional().describe("Page number inside the queries' result collection of work packages."),
          pageSize: z
            .number()
            .optional()
            .describe("Number of elements to display per page for the queries' result collection of work packages."),
          sortBy: z
            .string()
            .optional()
            .describe(
              "JSON specifying sort criteria. The sort criteria is applied to the query's result collection of work packages overriding the query's persisted sort criteria.",
            ),
          groupBy: z
            .string()
            .optional()
            .describe(
              "The column to group by. The grouping criteria is applied to the to the query's result collection of work packages overriding the query's persisted group criteria.",
            ),
          showSums: z
            .boolean()
            .optional()
            .describe(
              "Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query's result collection of work packages overriding the query's persisted sums property.",
            ),
          timestamps: z
            .string()
            .optional()
            .describe(
              'Indicates the timestamps to filter by when showing changed attributes on work packages. Values can be either ISO8601 dates, ISO8601 durations and the following relative date keywords "oneDayAgoHHMMHHMM", "lastWorkingDayHHMMHHMM", "oneWeekAgoHHMMHHMM", "oneMonthAgoHHMMHHMM". The first "HHMM" part represents the zero paded hours and minutes. The last "HHMM" part represents the timezone offset from UTC associated with the time. Values older than 1 day are accepted only with valid Enterprise Token available.',
            ),
          timelineVisible: z.boolean().optional().describe('Indicates whether the timeline should be shown.'),
          showHierarchies: z.boolean().optional().describe('Indicates whether the hierarchy mode should be enabled.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: {
      id: number;
      params?: ViewDefaultQueryForProjectParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      const { data } = await sdk.queries.viewDefaultQueryForProject(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_schema_for_project_queries',
    'Retrieve the schema for project queries.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.viewSchemaForProjectQueries(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_queries',
    'Returns a collection of queries. The collection can be filtered via query parameters similar to how work packages are filtered. Please note however, that the filters are applied to the queries and not to the work packages the queries in turn might return.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Currently supported filters are  project filters queries by the project they are assigned to. If the project filter is passed with the  not any operator, global queries are returned.  id filters queries based on their id  updatedat filters queries based on the last time they where updated',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListQueriesParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.listQueries(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_query',
    'When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a Query can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.createQuery(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'available_projects_for_query',
    'Gets a list of projects that are available as projects a query can be assigned to.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.availableProjectsForQuery(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_default_query',
    'Same as viewing an existing, persisted Queryhttpswww.openproject.orgdocsapiendpointsquerieslist-queries in its response, this resource returns an unpersisted query and by that allows to get the default query configuration. The client may also provide additional parameters which will modify the default query.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query's persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array .",
            ),
          offset: z.number().optional().describe("Page number inside the queries' result collection of work packages."),
          pageSize: z
            .number()
            .optional()
            .describe("Number of elements to display per page for the queries' result collection of work packages."),
          sortBy: z
            .string()
            .optional()
            .describe(
              "JSON specifying sort criteria. The sort criteria is applied to the query's result collection of work packages overriding the query's persisted sort criteria.",
            ),
          groupBy: z
            .string()
            .optional()
            .describe(
              "The column to group by. The grouping criteria is applied to the to the query's result collection of work packages overriding the query's persisted group criteria.",
            ),
          showSums: z
            .boolean()
            .optional()
            .describe(
              "Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query's result collection of work packages overriding the query's persisted sums property.",
            ),
          timestamps: z
            .string()
            .optional()
            .describe(
              'Indicates the timestamps to filter by when showing changed attributes on work packages. Values can be either ISO8601 dates, ISO8601 durations and the following relative date keywords "oneDayAgoHHMMHHMM", "lastWorkingDayHHMMHHMM", "oneWeekAgoHHMMHHMM", "oneMonthAgoHHMMHHMM". The first "HHMM" part represents the zero paded hours and minutes. The last "HHMM" part represents the timezone offset from UTC associated with the time, the offset can be positive or negative e.g."oneDayAgo01000100", "oneDayAgo0100-0100". Values older than 1 day are accepted only with valid Enterprise Token available.',
            ),
          timelineVisible: z.boolean().optional().describe('Indicates whether the timeline should be shown.'),
          timelineZoomLevel: z
            .string()
            .optional()
            .describe(
              'Indicates in what zoom level the timeline should be shown. Valid values are  days, weeks, months, quarters, and years.',
            ),
          showHierarchies: z.boolean().optional().describe('Indicates whether the hierarchy mode should be enabled.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ViewDefaultQueryParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.viewDefaultQuery(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'query_create_form',
    'Query Create Form',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.queryCreateForm(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_schema_for_global_queries',
    'Retrieve the schema for global queries, those, that are not assigned to a project.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.viewSchemaForGlobalQueries(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_query',
    "Retrieve an individual query as identified by the id parameter. Then end point accepts a number of parameters that can be used to override the resources' persisted parameters.",
    {
      id: z.number(),
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. The filters provided as parameters are not applied to the query but are instead used to override the query's persisted filters. All filters also accepted by the work packages endpoint are accepted. If no filter is to be applied, the client should send an empty array .",
            ),
          offset: z.number().optional().describe("Page number inside the queries' result collection of work packages."),
          pageSize: z
            .number()
            .optional()
            .describe("Number of elements to display per page for the queries' result collection of work packages."),
          columns: z.string().optional().describe('Selected columns for the table view.'),
          sortBy: z
            .string()
            .optional()
            .describe(
              "JSON specifying sort criteria. The sort criteria is applied to the query's result collection of work packages overriding the query's persisted sort criteria.",
            ),
          groupBy: z
            .string()
            .optional()
            .describe(
              "The column to group by. The grouping criteria is applied to the to the query's result collection of work packages overriding the query's persisted group criteria.",
            ),
          showSums: z
            .boolean()
            .optional()
            .describe(
              "Indicates whether properties should be summed up if they support it. The showSums parameter is applied to the to the query's result collection of work packages overriding the query's persisted sums property.",
            ),
          timestamps: z
            .string()
            .optional()
            .describe(
              'Indicates the timestamps to filter by when showing changed attributes on work packages. Values can be either ISO8601 dates, ISO8601 durations and the following relative date keywords "oneDayAgoHHMMHHMM", "lastWorkingDayHHMMHHMM", "oneWeekAgoHHMMHHMM", "oneMonthAgoHHMMHHMM". The first "HHMM" part represents the zero paded hours and minutes. The last "HHMM" part represents the timezone offset from UTC associated with the time, the offset can be positive or negative e.g."oneDayAgo01000100", "oneDayAgo0100-0100". Values older than 1 day are accepted only with valid Enterprise Token available.',
            ),
          timelineVisible: z.boolean().optional().describe('Indicates whether the timeline should be shown.'),
          timelineLabels: z.string().optional().describe('Overridden labels in the timeline view'),
          highlightingMode: z.string().optional().describe('Highlighting mode for the table view.'),
          highlightedAttributes: z
            .string()
            .optional()
            .describe(
              'Highlighted attributes mode for the table view when highlightingMode is inline. When set to  all highlightable attributes will be returned as highlightedAttributes.',
            ),
          showHierarchies: z.boolean().optional().describe('Indicates whether the hierarchy mode should be enabled.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; params?: ViewQueryParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.viewQuery(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'edit_query',
    'When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the write operation.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.editQuery(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_query',
    'Delete the query identified by the id parameter',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.deleteQuery(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'query_update_form',
    'Query Update Form',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.queryUpdateForm(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'star_query',
    'Star query',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.starQuery(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'unstar_query',
    'Unstar query',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queries.unstarQuery(args.id, args.requestConfig);
      return data;
    },
  );
  // Query Filter Instance Schema Service

  createApiTool(
    server,
    'list_query_filter_instance_schemas_for_project',
    'Returns the list of QueryFilterInstanceSchemas defined for a query of the specified project.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queryFilterInstanceSchema.listQueryFilterInstanceSchemasForProject(
        args.id,
        args.requestConfig,
      );
      return data;
    },
  );

  createApiTool(
    server,
    'list_query_filter_instance_schemas',
    'Returns the list of QueryFilterInstanceSchemas defined for a global query. That is a query not assigned to a project.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queryFilterInstanceSchema.listQueryFilterInstanceSchemas(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_query_filter_instance_schema',
    'Retrieve an individual QueryFilterInstanceSchema as identified by the id parameter.',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queryFilterInstanceSchema.viewQueryFilterInstanceSchema(args.id, args.requestConfig);
      return data;
    },
  );
  // Work Packages Service

  createApiTool(
    server,
    'get_project_work_package_collection',
    'Returns the collection of work packages that are related to the given project.',
    {
      id: z.number(),
      params: z
        .object({
          offset: z.number().optional().describe('Page number inside the requested collection.'),
          pageSize: z.number().optional().describe('Number of elements to display per page.'),
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. If no filter is to be applied, the client should send an empty array .',
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint.',
            ),
          groupBy: z.string().optional().describe('The column to group by.'),
          showSums: z
            .boolean()
            .optional()
            .describe('Indicates whether properties should be summed up if they support it.'),
          select: z.string().optional().describe('Comma separated list of properties to include.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: {
      id: number;
      params?: GetProjectWorkPackageCollectionParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      const { data } = await sdk.workPackages.getProjectWorkPackageCollection(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_project_work_package',
    'When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation.',
    {
      id: z.number(),
      params: z
        .object({
          notify: z
            .boolean()
            .optional()
            .describe(
              'Indicates whether change notifications e.g. via E-Mail should be sent. Note that this controls notifications for all users interested in changes to the work package e.g. watchers, author and assignee, not just the current user.',
            ),
        })
        .optional(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: {
      id: number;
      body?: any;
      params?: CreateProjectWorkPackageParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      const { data } = await sdk.workPackages.createProjectWorkPackage(
        args.id,
        args.body || {},
        args.params,
        args.requestConfig,
      );
      return data;
    },
  );

  createApiTool(
    server,
    'form_create_work_package_in_project',
    "This endpoint allows you to validation a new work package creation body in a specific project. It works similarly to the apiv3workpackagesform endpoint, but already specifies the work package's project in the path, so that it does not have to be defined in the request body.",
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.formCreateWorkPackageInProject(
        args.id,
        args.body || {},
        args.requestConfig,
      );
      return data;
    },
  );

  createApiTool(
    server,
    'project_available_assignees',
    'Gets a list of users that can be assigned to work packages in the given project.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.projectAvailableAssignees(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_work_packages',
    'Returns a collection of work packages.',
    {
      params: z
        .object({
          offset: z.number().optional().describe('Page number inside the requested collection.'),
          pageSize: z.number().optional().describe('Number of elements to display per page.'),
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. If no filter is to be applied, the client should send an empty array , otherwise a default filter is applied. A Currently supported filters are there are additional filters added by modules - assignedto - assigneeorgroup - attachmentbase - attachmentcontent - attachmentfilename - author - blocked - blocks - category - comment - createdat - customfield - datesinterval - description - doneratio - duedate - duplicated - duplicates - duration - estimatedhours - filelinkoriginid - follows - group - id - includes - linkabletostorageid - linkabletostorageurl - manualsort - milestone - onlysubproject - parent - partof - precedes - principalbase - priority - project - relatable - relates - required - requires - responsible - role - search - startdate - status - storageid - storageurl - subject - subjectorid - subproject - type - typeahead - updatedat - version - watcher - workpackage',
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint.',
            ),
          groupBy: z.string().optional().describe('The column to group by.'),
          showSums: z
            .boolean()
            .optional()
            .describe('Indicates whether properties should be summed up if they support it.'),
          select: z.string().optional().describe('Comma separated list of properties to include.'),
          timestamps: z
            .string()
            .optional()
            .describe(
              'In order to perform a baseline comparisondocsapibaseline-comparisons, you may provide one or several timestamps in ISO-8601 format as comma-separated list. The timestamps may be absolute or relative, such as ISO8601 dates, ISO8601 durations and the following relative date keywords "oneDayAgoHHMMHHMM", "lastWorkingDayHHMMHHMM", "oneWeekAgoHHMMHHMM", "oneMonthAgoHHMMHHMM". The first "HHMM" part represents the zero paded hours and minutes. The last "HHMM" part represents the timezone offset from UTC associated with the time, the offset can be positive or negative e.g."oneDayAgo01000100", "oneDayAgo0100-0100". Usually, the first timestamp is the baseline date, the last timestamp is the current date. Values older than 1 day are accepted only with valid Enterprise Token available.',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListWorkPackagesParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.listWorkPackages(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_work_package',
    'When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a WorkPackage can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation. A project link must be set when creating work packages through this route. When setting start date, finish date, and duration together, their correctness will be checked and a 422 error will be returned if one value does not match with the two others. You can make the server compute a value set only two values in the request and the third one will be computed and returned in the response. For instance, when sending  "startDate" "2022-08-23", duration "P2D" , the response will include  "dueDate" "2022-08-24" .',
    {
      params: z
        .object({
          notify: z
            .boolean()
            .optional()
            .describe(
              'Indicates whether change notifications e.g. via E-Mail should be sent. Note that this controls notifications for all users interested in changes to the work package e.g. watchers, author and assignee, not just the current user.',
            ),
        })
        .optional(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; params?: CreateWorkPackageParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.createWorkPackage(args.body || {}, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'form_create_work_package',
    'When calling this endpoint, the client provides a single object containing the properties and links to be created, in the body. The input is validated and a schema response is returned. If the validation errors of the response is empty, the same payload can be used to create a work package. Only the properties of the work package write model are allowed to set on a work package on creation. When setting start date, finish date, and duration together, their correctness will be checked and a validation error will be returned if one value does not match with the two others. You can make the server compute a value set only two values in the request and the third one will be computed and returned in the response. For instance, when sending  "startDate" "2022-08-23", duration "P2D" , the response will include  "dueDate" "2022-08-24" .',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.formCreateWorkPackage(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_work_package_schemas',
    'List all work package schemas that match the given filters. This endpoint does not return a successful response, if no filter is given.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  id The schema's id Schema id has the form projectid-workpackagetypeid.",
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params: ListWorkPackageSchemasParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.listWorkPackageSchemas(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_work_package_schema',
    'View Work Package Schema',
    {
      identifier: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { identifier: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.viewWorkPackageSchema(args.identifier, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_work_package',
    'Returns the specified work package.',
    {
      id: z.number(),
      params: z
        .object({
          timestamps: z
            .string()
            .optional()
            .describe(
              'In order to perform a baseline comparisondocsapibaseline-comparisons of the work-package attributes, you may provide one or several timestamps in ISO-8601 format as comma-separated list. The timestamps may be absolute or relative, such as ISO8601 dates, ISO8601 durations and the following relative date keywords "oneDayAgoHHMMHHMM", "lastWorkingDayHHMMHHMM", "oneWeekAgoHHMMHHMM", "oneMonthAgoHHMMHHMM". The first "HHMM" part represents the zero paded hours and minutes. The last "HHMM" part represents the timezone offset from UTC associated with the time, the offset can be positive or negative e.g."oneDayAgo01000100", "oneDayAgo0100-0100". Usually, the first timestamp is the baseline date, the last timestamp is the current date. Values older than 1 day are accepted only with valid Enterprise Token available.',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; params?: ViewWorkPackageParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.viewWorkPackage(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_work_package',
    'When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. Note that it is only allowed to provide properties or links supporting the write operation. Additionally to the fields the client wants to change, it is mandatory to provide the value of lockVersion which was received by the GET request this change originates from. The value of lockVersion is used to implement optimistic lockinghttpsen.wikipedia.orgwikiOptimisticconcurrencycontrol.',
    {
      id: z.number(),
      params: z
        .object({
          notify: z
            .boolean()
            .optional()
            .describe(
              'Indicates whether change notifications should be sent. Note that this controls notifications for all users interested in changes to the work package e.g. watchers, author and assignee, not just the current user.',
            ),
        })
        .optional(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: {
      id: number;
      body?: any;
      params?: UpdateWorkPackageParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      const { data } = await sdk.workPackages.updateWorkPackage(
        args.id,
        args.body || {},
        args.params,
        args.requestConfig,
      );
      return data;
    },
  );

  createApiTool(
    server,
    'delete_work_package',
    'Deletes the work package, as well as - all associated time entries - its hierarchy of child work packages',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.deleteWorkPackage(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_work_package_activities',
    'List work package activities',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.listWorkPackageActivities(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'comment_work_package',
    'Creates an activity for the selected work package and, on success, returns the updated activity.',
    {
      id: z.number(),
      params: z
        .object({
          notify: z
            .boolean()
            .optional()
            .describe(
              'Indicates whether change notifications e.g. via E-Mail should be sent. Note that this controls notifications for all users interested in changes to the work package e.g. watchers, author and assignee, not just the current user.',
            ),
        })
        .optional(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: {
      id: number;
      body?: any;
      params?: CommentWorkPackageParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      const { data } = await sdk.workPackages.commentWorkPackage(
        args.id,
        args.body || {},
        args.params,
        args.requestConfig,
      );
      return data;
    },
  );

  createApiTool(
    server,
    'work_package_available_assignees',
    'Gets a list of users that can be assigned to the given work package.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.workPackageAvailableAssignees(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'available_projects_for_work_package',
    'Gets a list of projects that are available as projects to which the work package can be moved.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.availableProjectsForWorkPackage(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_available_relation_candidates',
    'Available relation candidates',
    {
      id: z.number(),
      params: z
        .object({
          pageSize: z.number().optional().describe('Maximum number of candidates to list default 10'),
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same filters as the work packageshttpswww.openproject.orgdocsapiendpointswork-packages endpoint.',
            ),
          query: z.string().optional().describe('Shortcut for filtering by ID or subject'),
          type: z.string().optional().describe('Type of relation to find candidates for default "relates"'),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same sort criteria as the work packageshttpswww.openproject.orgdocsapiendpointswork-packages endpoint.',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: {
      id: number;
      params?: ListAvailableRelationCandidatesParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      const { data } = await sdk.workPackages.listAvailableRelationCandidates(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'available_watchers',
    'Gets a list of users that are able to be watchers of the specified work package.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.availableWatchers(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_work_package_file_links',
    "Gets all file links of a work package. As a side effect, for every file link a request is sent to the storage's origin to fetch live data and patch the file link's data before returning, as well as retrieving permissions of the user on this origin file.",
    {
      id: z.number(),
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. The following filters are supported - storage',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: {
      id: number;
      params?: ListWorkPackageFileLinksParams;
      requestConfig?: RequestConfig;
    }): Promise<any> => {
      const { data } = await sdk.workPackages.listWorkPackageFileLinks(args.id, args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_work_package_file_link',
    "Creates file links on a work package. The request is interpreted as a bulk insert, where every element of the collection is validated separately. Each element contains the origin meta data and a link to the storage, the file link is about to point to. The storage link can be provided as a resource link with id or as the host url. The file's id and name are considered mandatory information. The rest of the origin meta data SHOULD be provided by the client. The mimeType SHOULD be a standard mime type. An empty mime type will be handled as unknown. To link a folder, the custom mime type applicationx-op-directory MUST be used. Up to 20 file links can be submitted at once. If any element data is invalid, no file links will be created. If a file link with matching origin id, work package, and storage already exists, then it will not create an additional file link or update the meta data. Instead the information from the existing file link will be returned.",
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.createWorkPackageFileLink(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'form_edit_work_package',
    'When calling this endpoint, the client provides a single object containing the properties and links to be edited, in the body. The input is validated and a schema response is returned. If the validation errors of the response is empty, the same payload can be used to edit the work package. Only the properties of the work package write model are allowed to set on a work package on editing. When setting start date, finish date, and duration together, their correctness will be checked and a validation error will be returned if one value does not match with the two others. You can make the server compute a value set only two values in the request and the third one will be computed and returned in the response. For instance, when sending  "startDate" "2022-08-23", duration "P2D" , the response will include  "dueDate" "2022-08-24" .',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.formEditWorkPackage(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'revisions',
    'Gets a list of revisions that are linked to this work package, e.g., because it is referenced in the commit message of the revision. Only linked revisions from repositories are shown if the user has the view changesets permission in the defining project.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.revisions(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'reminders',
    'Gets a list of your upcoming reminders for this work package.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.reminders(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_watchers',
    'List watchers',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.listWatchers(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'add_watcher',
    'Adds a watcher to the specified work package. The request is expected to contain a single JSON object, that contains a link object under the user key. The response will be user added as watcher. In case the user was already watching the work package an HTTP 200 is returned, an HTTP 201 if the user was added as a new watcher.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.addWatcher(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'remove_watcher',
    'Removes the specified user from the list of watchers for the given work package. If the request succeeds, the specified user is not watching the work package anymore. Note This might also be the case, if the specified user did not watch the work package prior to the request.',
    {
      id: z.number(),
      userId: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; userId: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.workPackages.removeWatcher(args.id, args.userId, args.requestConfig);
      return data;
    },
  );
  // Types Service

  createApiTool(
    server,
    'list_types_available_in_a_project',
    'This endpoint lists the types that are available in a given project.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.types.listTypesAvailableInAProject(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_all_types',
    'List all Types',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.types.listAllTypes(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_type',
    'View Type',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.types.viewType(args.id, args.requestConfig);
      return data;
    },
  );
  // Versions Service

  createApiTool(
    server,
    'list_versions_available_in_a_project',
    'This endpoint lists the versions that are available in a given project. Note that due to sharing this might be more than the versions defined by that project.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.listVersionsAvailableInAProject(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'list_versions',
    'Returns a collection of versions. The client can choose to filter the versions similar to how work packages are filtered. In addition to the provided filters, the server will reduce the result set to only contain versions, for which the requesting client has sufficient permissions viewworkpackages.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  sharing filters versions by how they are shared within the server none, descendants, hierarchy, tree, system.',
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported attributes are  id Sort by the version id  name Sort by the version name using numeric collation, comparing sequences of decimal digits by their numeric value  semvername Deprecated, use name instead',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListVersionsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.listVersions(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_version',
    "Creates a new version applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version's attributes and are accepted by the endpoint. You can use the form and schema to be retrieve the valid attribute values and by that be guided towards successful creation.",
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.createVersion(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'available_projects_for_versions',
    'Gets a list of projects in which a version can be created in. The list contains all projects in which the user issuing the request has the manage versions permissions.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.availableProjectsForVersions(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'version_create_form',
    'Version create form',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.versionCreateForm(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_version_schema',
    'View version schema',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.viewVersionSchema(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_version',
    'View version',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.viewVersion(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_version',
    "Updates the given version by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a version's attributes and are accepted by the endpoint.",
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.updateVersion(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_version',
    'Deletes the version. Work packages associated to the version will no longer be assigned to it.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.deleteVersion(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'version_update_form',
    'Version update form',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.versions.versionUpdateForm(args.id, args.requestConfig);
      return data;
    },
  );
  // Query Columns Service

  createApiTool(
    server,
    'view_query_column',
    'Retrieve an individual QueryColumn as identified by the id parameter.',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queryColumns.viewQueryColumn(args.id, args.requestConfig);
      return data;
    },
  );
  // Query Filters Service

  createApiTool(
    server,
    'view_query_filter',
    'Retrieve an individual QueryFilter as identified by the id parameter.',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queryFilters.viewQueryFilter(args.id, args.requestConfig);
      return data;
    },
  );
  // Query Operators Service

  createApiTool(
    server,
    'view_query_operator',
    'Retrieve an individual QueryOperator as identified by the id parameter.',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.queryOperators.viewQueryOperator(args.id, args.requestConfig);
      return data;
    },
  );
  // Query Sort Bys Service

  createApiTool(
    server,
    'view_query_sort_by',
    'Retrieve an individual QuerySortBy as identified by the id parameter.',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.querySortBys.viewQuerySortBy(args.id, args.requestConfig);
      return data;
    },
  );
  // Relations Service

  createApiTool(
    server,
    'list_relations',
    'Lists all relations according to the given optional, logically conjunctive filters and ordered by ID. The response only includes relations between work packages which the user is allowed to see.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Valid fields to filter by are - id - ID of relation - from - ID of work package from which the filtered relations emanates. - to - ID of work package to which this related points. - involved - ID of either the from or the to work package. - type - The type of relation to filter by, e.g. "follows".',
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint.',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListRelationsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.relations.listRelations(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_relation',
    'Get a single relation specified by its unique identifier.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.relations.getRelation(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_relation',
    'When calling this endpoint the client provides a single object, containing the properties and links that it wants to change, in the body. It is only allowed to provide properties or links supporting the write operation. Note that changing the type of a relation invariably also changes the respective reverseType as well as the "name" of it. The returned Relation object will reflect that change. For instance if you change a Relation\'s type to "follows" then the reverseType will be changed to precedes. It is not allowed to change a relation\'s involved work packages.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.relations.updateRelation(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_relation',
    'Deletes the relation.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.relations.deleteRelation(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_relation',
    'Create a work package relation on the given work package. A successful creation will result in a relation between two work packages, thus appearing on both involved work package resources.',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.relations.createRelation(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );
  // Previewing Service

  createApiTool(
    server,
    'preview_markdown_document',
    'Preview Markdown document',
    {
      params: z
        .object({
          context: z
            .string()
            .optional()
            .describe(
              'API-Link to the context in which the rendering occurs, for example a specific work package. If left out only context-agnostic rendering takes place. Please note that OpenProject features markdown-extensions on top of the extensions GitHub Flavored Markdown gfm already provides that can only work given a context e.g. display attached images. Supported contexts  apiv3workpackagesid - an existing work package',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: PreviewMarkdownDocumentParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.previewing.previewMarkdownDocument(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'preview_plain_document',
    'Preview plain document',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.previewing.previewPlainDocument(args.requestConfig);
      return data;
    },
  );
  // Revisions Service

  createApiTool(
    server,
    'view_revision',
    'View revision',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.revisions.viewRevision(args.id, args.requestConfig);
      return data;
    },
  );
  // Roles Service

  createApiTool(
    server,
    'list_roles',
    "List all defined roles. This includes built in roles like 'Anonymous' and 'Non member'.",
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  grantable filters roles based on whether they are selectable for a membership  unit filters roles based on the unit 'project' or 'system' for which they are selectable for a membership",
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListRolesParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.roles.listRoles(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_role',
    'Fetch an individual role.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.roles.viewRole(args.id, args.requestConfig);
      return data;
    },
  );
  // Statuses Service

  createApiTool(
    server,
    'list_statuses',
    'Returns a collection of all work package statuses.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.statuses.listStatuses(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_status',
    'Returns a work package status by its unique identifier.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.statuses.getStatus(args.id, args.requestConfig);
      return data;
    },
  );
  // Time entries Service

  createApiTool(
    server,
    'list_time_entries',
    'Lists time entries. The time entries returned depend on the filters provided and also on the permission of the requesting user.',
    {
      params: z
        .object({
          offset: z.number().optional().describe('Page number inside the requested collection.'),
          pageSize: z.number().optional().describe('Number of elements to display per page.'),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported sorts are  id Sort by primary key  hours Sort by logged hours  spenton Sort by spent on date  createdat Sort by time entry creation datetime  updatedat Sort by the time the time entry was updated last',
            ),
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  workpackage Filter time entries by work package  project Filter time entries by project  user Filter time entries by users  ongoing Filter for your ongoing timers  spenton Filter time entries by spent on date  createdat Filter time entries by creation datetime  updatedat Filter time entries by the last time they where updated  activity Filter time entries by time entry activity',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListTimeEntriesParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.listTimeEntries(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_time_entry',
    "Creates a new time entry applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries' attributes and are accepted by the endpoint.",
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.createTimeEntry(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'time_entry_update_form',
    'Time entry update form',
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.timeEntryUpdateForm(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'available_projects_for_time_entries',
    'Gets a list of projects in which a time entry can be created in or be assigned to on update. The list contains all projects in which the user issuing the request has the necessary permissions.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.availableProjectsForTimeEntries(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'time_entry_create_form',
    'Time entry create form',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.timeEntryCreateForm(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_time_entry_schema',
    'View time entry schema',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.viewTimeEntrySchema(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'get_time_entry',
    'Retrieves a single time entry identified by the given id.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.getTimeEntry(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_time_entry',
    "Updates the given time entry by applying the attributes provided in the body. Please note that while there is a fixed set of attributes, custom fields can extend a time entries' attributes and are accepted by the endpoint.",
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.updateTimeEntry(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_time_entry',
    'Permanently deletes the specified time entry.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntries.deleteTimeEntry(args.id, args.requestConfig);
      return data;
    },
  );
  // Time entry activities Service

  createApiTool(
    server,
    'get_time_entries_activity',
    'Fetches the time entry activity resource by the given id.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.timeEntryActivities.getTimeEntriesActivity(args.id, args.requestConfig);
      return data;
    },
  );
  // Users Service

  createApiTool(
    server,
    'list_users',
    'Lists users. Only administrators or users with any of the following can access this resource - managemembers - manageuser - shareworkpackages',
    {
      params: z
        .object({
          offset: z.number().optional().describe('Page number inside the requested collection.'),
          pageSize: z.number().optional().describe('Number of elements to display per page.'),
          filters: z
            .string()
            .optional()
            .describe(
              "JSON specifying filter conditions. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint. Currently supported filters are  status Status the user has  group Name of the group in which to-be-listed users are members.  name Filter users in whose first or last names, or email addresses the given string occurs.  login User's login",
            ),
          sortBy: z
            .string()
            .optional()
            .describe(
              'JSON specifying sort criteria. Accepts the same format as returned by the querieshttpswww.openproject.orgdocsapiendpointsqueries endpoint.',
            ),
          select: z.string().optional().describe('Comma separated list of properties to include.'),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListUsersParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.listUsers(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_user',
    'Creates a new user. Only administrators and users with manageuser global permission are allowed to do so. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. Valid values for status 1 "active" - In this case a password has to be provided in addition to the other attributes. 2 "invited" - In this case nothing but the email address is required. The rest is optional. An invitation will be sent to the user.',
    {
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.createUser(args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_user_schema',
    'The schema response use two exemplary custom fields that extend the schema response. Depending on your instance and custom field configuration, the response will look somewhat different.',
    {
      requestConfig: RequestConfigSchema,
    },
    async (args: { requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.viewUserSchema(args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_user',
    'View user',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.viewUser(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'update_user',
    "Updates the user's writable attributes. When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body.",
    {
      id: z.number(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.updateUser(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'delete_user',
    'Permanently deletes the specified user account.',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.deleteUser(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'user_update_form',
    'User update form',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.userUpdateForm(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'lock_user',
    'Lock user',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.lockUser(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'unlock_user',
    'Unlock user',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.users.unlockUser(args.id, args.requestConfig);
      return data;
    },
  );
  // Values::Property Service

  createApiTool(
    server,
    'view_values_schema',
    'The schema of a Values resource.',
    {
      id: z.string(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.valuesProperty.viewValuesSchema(args.id, args.requestConfig);
      return data;
    },
  );
  // Views Service

  createApiTool(
    server,
    'list_views',
    'Returns a collection of Views. The collection can be filtered via query parameters similar to how work packages are filtered.',
    {
      params: z
        .object({
          filters: z
            .string()
            .optional()
            .describe(
              'JSON specifying filter conditions. Currently supported filters are  project filters views by the project their associated query is assigned to. If the project filter is passed with the  not any operator, global views are returned.  id filters views based on their id  type filters views based on their type',
            ),
        })
        .optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { params?: ListViewsParams; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.views.listViews(args.params, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'view_view',
    'View view',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.views.viewView(args.id, args.requestConfig);
      return data;
    },
  );

  createApiTool(
    server,
    'create_views',
    'When calling this endpoint the client provides a single object, containing at least the properties and links that are required, in the body. The required fields of a View can be found in its schema, which is embedded in the respective form. Note that it is only allowed to provide properties or links supporting the write operation. There are different subtypes of Views e.g. ViewsWorkPackagesTable with each having its own endpoint for creating that subtype e.g.  apiv3viewsworkpackagestable for ViewsWorkPackagesTable  apiv3viewsteamplanner for ViewsTeamPlanner  apiv3viewsworkpackagescalendar for ViewsWorkPackagesCalendar Not yet implemented To get the list of available subtypes and by that the endpoints for creating a subtype, use the    apiv3viewsschemas  endpoint.',
    {
      id: z.string(),
      body: z.any().optional(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: string; body?: any; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.views.createViews(args.id, args.body || {}, args.requestConfig);
      return data;
    },
  );
  // Wiki Pages Service

  createApiTool(
    server,
    'view_wiki_page',
    'Retrieve an individual wiki page as identified by the id parameter',
    {
      id: z.number(),
      requestConfig: RequestConfigSchema,
    },
    async (args: { id: number; requestConfig?: RequestConfig }): Promise<any> => {
      const { data } = await sdk.wikiPages.viewWikiPage(args.id, args.requestConfig);
      return data;
    },
  );
}
